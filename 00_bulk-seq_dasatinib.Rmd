---
title: "Bulk Sequencing Analysis"
output: html_document
---

-   Output in: archive\\blacklab\\KieranRedpath\\RNAseqHuman2\\analysis\\output
# Setup and QC
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

### Load Packages
```{r}
# Not all of these are used for thesis stuff, many are only for exploratory analyses
library(dplyr)
library(limma)
library(edgeR)
library(gplots)
library(goseq)
library(AnnotationDbi)
library(reactome.db)
library(org.Hs.eg.db)
library(ggplot2)
library(ggvenn)
library(ReactomePA)
library(stringr)
library(clusterProfiler) # Overwrites select and filter, but they're both copied from dplyr apparently
library(enrichplot)
library(fgsea)

# Load human genome IDs
hs <- org.Hs.eg.db

# Set random seed for reproducibility
set.seed(42)
```

### Define variables and function for rounding thesis tables
```{r}
# Round numeric columns to 3 sig.digits
sig.digits <- 3
# Create a function that determines when to use which type of rounding in a data.frame
pref.round <- function(x) {
  if (is.numeric(x)) {
    ifelse(
      x %% 1 == 0,  # Skip rounding for whole numbers
      x,
      ifelse(
        abs(x) < 0.1,  # Use scientific notation for abs(x) < 0.1
        formatC(x, format = "e", digits = sig.digits),
        formatC(x, format = "f", digits = sig.digits)  # Use fixed-point otherwise
      )
    )
  } else {
    x  # Return non-numeric values as-is
  }
}
```


### Process counts data
```{r}
# # Load data (this file is not currently on the compute server, so the processed copy of fcData is provided instead as a .RDS file at the end of this chunk)
# # fcData <- read.table("../counts/human-counts.txt", header=TRUE)
# 
# # Inspect data
# # fcData %>% head()
# # dim(fcData)
# # names(fcData)
# 
# # Rename samples to sample number for readability
# names(fcData)[7:16] <- c(1:6, 13:16)
# # Remove columns for samples 13:16 for this analysis
# fcData <- fcData[, 1:12]

# Load file, processed as above
fcData <- readRDS("data/bulk-seq_dasatinib_annotated.RDS")
```

### Separate and inspect count data
* Inspect counts
* Inspect counts per sample
```{r, echo = TRUE}
# Inspect counts
counts <- fcData[7:12]
rownames(counts) <- fcData$Geneid
head(counts)

# Make a duplicate for comparison
countsRaw <- counts

# Inspect counts per sample
colSums(counts) %>% barplot(., las=3, ylab="Reads mapped per sample")
# Fairly similar
```

### Counts density and distribution
* Visualise counts density and distribution. There are many low counts and counts of 0
* How many counts of 0 are present in each sample, and each sample as a proportion? Roughly 60% of count data in each sample are 0's
* What proportion of genes have no count data? 27% of genes have no count data in any samples
```{r, echo = TRUE}
# Visualise counts density and distribution
plot(density(log(counts[,1]+0.5)), ylim=c(0,0.5))
for(i in 1:6) lines(density(log(counts[,i]+0.5)), col=i)
boxplot(log(as.matrix(counts)+0.5) ~ col(as.matrix(counts)))
# there are many low counts and counts of 0

# How many counts of 0 are present in each sample?
colSums(counts==0)
# How many counts of 0 are present in each sample as a proportion?
colSums(counts==0)/nrow(counts)
# Roughly 60% of count data in each sample are 0's
# What proportion of genes have no count data?
sum(rowSums(counts==0)==0)/nrow(counts)
# 30% of genes have no count data in any samples
```

### Filter counts to increase power
* Create design matrix to compare the three Das samples to DMSO
* Filter out genes with low counts
```{r}
# Create a design matrix that classifies samples based on their treatment and compares them all to DMSO as a baseline
trt <- rep(letters[1:2], each = 3)
design <- model.matrix(~trt)

# Filter out genes with very low counts across all samples - using defaults. STICK WITH LESS STRICT FILTERS cause you don't want to throw too much stuff out.
countskeep <- filterByExpr(counts, design=design, min.count = 10, min.total.count = 15, min.prop = 0.7)
sum(countskeep == TRUE)
sum(countskeep == FALSE)

counts <- counts[countskeep,]
```

# Differential Gene Expression Analysis

### Design and normalisation
```{r}
# Create design matrix with limma
dge <- DGEList(counts=counts) 
dge <- calcNormFactors(dge)
# Analyse logCPM
logCPM <- cpm(dge, log=TRUE, prior.count = 1)
head(logCPM, 3)

# Voom to prepare for linear modelling
v <- voom(dge, design, plot=TRUE)
```

### Explore alignment between samples
* Plot V\$E for samples in a treatment group against each other to see how much they agree
```{r}
# Plot v$E for samples in a treatment group against each other to see how much they agree

# Compare samples to each other
E <- as.data.frame(v$E)
colnames(E) <- c("DMSO_A1", "DMSO_A2", "DMSO_A3", "Das_A4", "Das_A5", "Das_A6")

# Plot the first two DMSO samples against each other
cor.test(E[,1], E[,2], method = "spearman") %>% print(.)
print(
  ggplot(E, aes(x = E[,1], y = E[,2])) +
    geom_point() +
    xlab(colnames(E)[1]) +
    ylab(colnames(E)[2])
)

# Plot the first two Dasatinib samples against each other
cor.test(E[,4], E[,5], method = "spearman") %>% print(.)
print(
  ggplot(E, aes(x = E[,4], y = E[,5])) +
    geom_point() +
    xlab(colnames(E)[4]) +
    ylab(colnames(E)[5])
)
```

* Compare all Das samples to DMSO
```{r, include = FALSE}
# Compare all Das samples to DMSO_A1
for(s in 4:6){
  cor.test(E[,1], E[,s], method = "spearman") %>% print(.)
  print(
    ggplot(E, aes(x = E[,1], y = E[,s])) +
      geom_point() +
      xlab(colnames(E)[1]) +
      ylab(colnames(E)[s])
  )
  ggsave(paste0("00_output/", colnames(E)[1], "_Vs_", colnames(E)[s], ".png"))
}

# Compare all Das samples to DMSO_A2
for(s in 4:6){
  cor.test(E[,2], E[,s], method = "spearman") %>% print(.)
  print(
    ggplot(E, aes(x = E[,2], y = E[,s])) +
      geom_point() +
      xlab(colnames(E)[2]) +
      ylab(colnames(E)[s])
  )
  ggsave(paste0("00_output/", colnames(E)[2], "_Vs_", colnames(E)[s], ".png"))
}

# Compare all Das samples to DMSO_A3
for(s in 4:6){
  cor.test(E[,3], E[,s], method = "spearman") %>% print(.)
  print(
    ggplot(E, aes(x = E[,3], y = E[,s])) +
      geom_point() +
      xlab(colnames(E)[3]) +
      ylab(colnames(E)[s])
  )
  ggsave(paste0("00_output/", colnames(E)[3], "_Vs_", colnames(E)[s], ".png"))
}
```
Output is suppressed, but Das is very similar to DMSO, (in fact almost identical).

* Do the same again, but this time without having filtered counts
* First, samples against each other (unfiltered) - output is supressed
```{r, include = FALSE}
##### Try the same thing but with every single gene, before filtering counts:
# Create design matrix with limma
dge.RAW <- DGEList(counts=countsRaw) 
dge.RAW <- calcNormFactors(dge.RAW)
# Analyse logCPM
logCPM.RAW <- cpm(dge.RAW, log=TRUE, prior.count=3)
head(logCPM.RAW, 3)

# Voom to prepare for linear modelling
v.RAW <- voom(dge.RAW, design, plot=TRUE)

E.RAW <- as.data.frame(v.RAW$E)
colnames(E.RAW) <- c("DMSO_A1", "DMSO_A2", "DMSO_A3", "Das_A4", "Das_A5", "Das_A6")

# Plot the first two DMSO samples against each other
cor.test(E.RAW[,1], E.RAW[,2], method = "spearman") %>% print(.)
print(
  ggplot(E.RAW, aes(x = E.RAW[,1], y = E.RAW[,2])) +
    geom_point() +
    xlab(colnames(E.RAW)[1]) +
    ylab(colnames(E.RAW)[2])
)

# Plot the first two Dasatinib samples against each other
cor.test(E.RAW[,4], E.RAW[,5], method = "spearman") %>% print(.)
print(
  ggplot(E.RAW, aes(x = E.RAW[,4], y = E.RAW[,5])) +
    geom_point() +
    xlab(colnames(E.RAW)[4]) +
    ylab(colnames(E.RAW)[5])
)
```

* Next, all Das samples against DMSO_A1, DMSO_A2, and DMSO_A3 (unfiltered)
```{r}
# Compare all Das samples to DMSO_A1
for(s in 4:6){
  cor.test(E.RAW[,1], E.RAW[,s], method = "spearman") %>% print(.)
  print(
    ggplot(E.RAW, aes(x = E.RAW[,1], y = E.RAW[,s])) +
      geom_point() +
      xlab(colnames(E.RAW)[1]) +
      ylab(colnames(E.RAW)[s])
  )
  ggsave(paste0("00_output/unfiltered_", colnames(E.RAW)[1], "_Vs_", colnames(E.RAW)[s], ".png"))
}

# Compare all Das samples to DMSO_A2
for(s in 4:6){
  cor.test(E.RAW[,2], E.RAW[,s], method = "spearman") %>% print(.)
  print(
    ggplot(E.RAW, aes(x = E.RAW[,2], y = E.RAW[,s])) +
      geom_point() +
      xlab(colnames(E.RAW)[2]) +
      ylab(colnames(E.RAW)[s])
  )
  ggsave(paste0("00_output/unfiltered_", colnames(E.RAW)[2], "_Vs_", colnames(E.RAW)[s], ".png"))
}

# Compare all Das samples to DMSO_A3
for(s in 4:6){
  cor.test(E.RAW[,3], E.RAW[,s], method = "spearman") %>% print(.)
  print(
    ggplot(E.RAW, aes(x = E.RAW[,3], y = E.RAW[,s])) +
      geom_point() +
      xlab(colnames(E.RAW)[3]) +
      ylab(colnames(E.RAW)[s])
  )
  ggsave(paste0("00_output/unfiltered_", colnames(E.RAW)[3], "_Vs_", colnames(E.RAW)[s], ".png"))
}
```
The correlation is slightly less strong amongst these samples, but still basically identical

# Fit the linear model and create toptable
* Define DE genes and create the toptable for each comparison
```{r}
# Create linear matrix
fit <- lmFit(v, design) %>% eBayes(.)
# Create a single toptable, as the only  comparison is all 3 DMSO samples vs all 3 Das samples
tt <- topTable(fit, coef = 2, n = nrow(counts))

# Identify which group has higher expression by comparing counts and trt at some point
# Limma uses alphabetical order: the genes with a positive logFC are more expressed in the group that is later alphabetically (I think? but you might not have coded it so that works, since the design matrix is just binary, in which case Das samples come second)
```

# Annotate tt and create filtered copies for downstream analyses
* Filter genes a little bit based on abs(FC) and significant adj. p-values
* Add gene symbols to toptable
* Creates outputs: ttsigFC (adj. p-value \< 0.05, abs(logFC) \>= 2) ttsigwall (adj. p-value \< 0.05)
```{r}
# Use this information to identify genes with high abs(FC) and significant adj p-values
# Create list of gene IDs, pulling from toptable
GeneKey <- AnnotationDbi::select(hs,
                                 keys=fcData$Geneid,
                                 columns = c("ENSEMBL", "SYMBOL", "ENTREZID"),
                                 keytype = "ENSEMBL")

# Add gene symbols to toptable
tt$Symbol <- GeneKey$SYMBOL[match(rownames(tt), GeneKey$ENSEMBL)]

# Tidy up the environment
rm(list = c("GeneKey"))

# Define significance by adj p-value and significant fold change (log2(4)=2, so 2x logFC or 4x FC) for reactome enrichment, and also just on p-value
# Messing around with some of these filters so that half to 3/4 of the genome isn't DE is probably a good idea
# This is used for GOSEQ reactome analysis:
ttsigFC <- filter(tt, tt$adj.P.Val < 0.2 & abs(tt$logFC) >= 1)
# Filter genes for significance - see what happens if you put in a threshold of 0.1:
ttsigwall <- filter(tt, tt$adj.P.Val < 0.2)
# ttsigwall <- filter(tt, tt$adj.P.Val < 0.1)
```

# Over-representation Analysis with goseq

### Gene ontolgy enrichment analysis with goseq
* Assign significance to genes from toptable for goseq GO term analysis
* Carry out GO analysis with Wallenius method (correction for gene length)
* Carry out GO analysis with hypergeometric method (no correction for gene lenth)
```{r, include = FALSE}
# Assign significance to genes from toptables
# Only on p-value
genes <- ifelse(tt$adj.P.Val < 0.2, 1, 0)
# On p-value and logFC - is this potentially biased, in that I'm putting significant genes that are only slightly differentially expressed in the non-significant group, causing disruption? Could duplicate tt and cut out low FC genes to solve this
#genes <- ifelse(tt$adj.P.Val < 0.05 & abs(tt$logFC) >= 2, 1, 0)
names(genes) <- rownames(tt)
print(table(genes))

# goseq processing for GO terms
pwf <- nullp(genes, genome="hg19", id="ensGene")
GO.wall <- goseq(pwf, genome="hg19", id="ensGene")
# Adjust p-values
GO.wall$padj <- p.adjust(GO.wall$over_represented_pvalue, method="fdr")
GO.wall <- filter(GO.wall, GO.wall$padj < 0.05)

# Carry out this analysis again,but using the hypergeometric method (i.e. no length-correction). If there isn't too much difference, this can be validation for using GSEA instead of DE to identify enriched processes.

# goseq processing for GO terms
pwf <- nullp(genes, genome="hg19", id="ensGene")
GO.hyper <- goseq(pwf, genome="hg19", id="ensGene", method="Hypergeometric")
# Adjust p-values
GO.hyper$padj <- p.adjust(GO.hyper$over_represented_pvalue, method="fdr")
GO.hyper <- filter(GO.hyper, GO.hyper$padj < 0.05)
```

* Compare the number of significant GO terms with/without length-correction
```{r}
# Compare the number of significant GO terms with or without length-correction
venn(list(Wallenius = GO.wall$term, Hypergeometric = GO.hyper$term))

# Check size of GO terms
sort(GO.wall$numInCat, decreasing=TRUE) %>% barplot(., ylab="Total genes in reactome pathway")

# Filter to remove very large GO terms - Over 100 genes in category, but doesn't seem to provide anything useful after light testing
# GO.test <- GO.wall[[2]]
# GO.testx <- filter(GO.test, GO.test$numInCat < 200)
```

# Reactome Pathway Analysis with ReactomePA and goseq
* Define significant and non-significant genes for Reactome pathway analysis
```{r}
# Convert gene names to entrez IDs for mapping to reactome

# Extract pathway names and human-only pathways from reactome
rName <- as.list(reactomePATHNAME2ID)
rPathName <- as.list(reactomePATHID2NAME)
rName <- rName[grep("Homo sapiens", names(rName))]
# Extract pathway genes from reactome
rGenes <- as.list(reactomePATHID2EXTID)
rGenesPath <- rGenes[match(rName, names(rGenes))]
rGenesPath <- lapply(rGenesPath, unique)
rGeneByPath <- as.list(reactomeEXTID2PATHID)
rPathName <- as.list(reactomePATHID2NAME)

# Separate significant and non-significant genes for reactome analysis
ttGenesEntrez <- AnnotationDbi::select(hs,
                                       keys = as.character(na.omit(rownames(tt))),
                                       columns = "ENTREZID",
                                       keytype = "ENSEMBL")

ttsigwallGenesEntrez <- AnnotationDbi::select(hs,
                                              keys = as.character(na.omit(rownames(ttsigwall))),
                                              columns = "ENTREZID",
                                              keytype = "ENSEMBL")

# Instead do this defining significance with fold change and p value
# ttsigwallGenesEntrez <- AnnotationDbi::select(hs, 
#                                               keys = as.character(na.omit(rownames(ttsigFC))),
#                                               columns = "ENTREZID",
#                                               keytype = "ENSEMBL")



# Define which of your genes are in the reactome database 
allGenes <- intersect( ttGenesEntrez$ENTREZID, unique(unlist(rGenesPath)) )

sigGenes <- intersect( ttsigwallGenesEntrez$ENTREZID, unique(unlist(rGenesPath)) )

# Define which genes are significant
plotGenes <- rep(0, length(allGenes))
names(plotGenes) <- allGenes
plotGenes[match(sigGenes, names(plotGenes))] <- 1
print(table(plotGenes))

# Which genes are relevant to the dataset?
mt <- match(allGenes, names(rGeneByPath))
rGeneByPathFinal <- lapply(rGeneByPath[mt], function(x) intersect(x, names(rGenesPath)))
```

### Use ReactomePA to identify enriched reactome pathways without length-correction, and prepare for GSEA
* Use ReactomePA to identify enriched reactome pathways with gene significance defined as adj. p-value < 0.05, with the hypergeometric method
* Create list of genes ranked by t statistic for GSEA
```{r}
# Create something to work off
# Filter by adj p-value
# For RPA.hyper
ttsig <- filter(tt, tt$adj.P.Val < 0.2) # & abs(tt$logFC) >= 2)
ttsigGenesEntrez <- AnnotationDbi::select(hs, 
                                          keys = as.character(na.omit(rownames(ttsig))),
                                          columns = "ENTREZID",
                                          keytype = "ENSEMBL")

# Filter out duplicate matches so t statistic can be added
ttsigGenesEntrez <- ttsigGenesEntrez[match(rownames(ttsig), ttsigGenesEntrez$ENSEMBL), ]
# Add t statistic column for ranking
ttsigGenesEntrez$t <- ttsig$t
# Rank by t statistic
ttsigGenesEntrez <- ttsigGenesEntrez[order(ttsigGenesEntrez$t), ]

# For RPA.gsea
ttsig.gsea <- tt #filter(tt, tt$adj.P.Val < 0.05 & abs(tt$logFC) >= 2)
ttsigGenesEntrez.gsea <- AnnotationDbi::select(hs, 
                                               keys = as.character(na.omit(rownames(ttsig.gsea))),
                                               columns = "ENTREZID",
                                               keytype = "ENSEMBL")
# Filter out duplicate matches so t statistic can be added
ttsigGenesEntrez.gsea <- ttsigGenesEntrez.gsea[match(rownames(ttsig.gsea), ttsigGenesEntrez.gsea$ENSEMBL), ]
# Add t statistic column for ranking
ttsigGenesEntrez.gsea$t <- ttsig.gsea$t
# Rank by t statistic
ttsigGenesEntrez.gsea <- ttsigGenesEntrez.gsea[order(ttsigGenesEntrez.gsea$t), ]
# Cut down to just entrez IDs and t stat for gsePathway in an ordered, named numeric vector
ttsigGenesEntrezGSEA <- ttsigGenesEntrez.gsea$t
names(ttsigGenesEntrezGSEA) <- ttsigGenesEntrez.gsea$ENTREZID
ttsigGenesEntrezGSEA <- sort(ttsigGenesEntrezGSEA, decreasing = TRUE)

# Reactome pathway enrichment with default, hypergeometric method
RPA.hyper <- enrichPathway(gene=ttsigGenesEntrez$ENTREZID, organism="human", pvalueCutoff=0.05, readable=T)
### At the end of this document, compare these to results from goseq (hypergeometric)
```
########### This runs but for some reason creates a blank heatmap ###########

### Gene-set Enrichment Analysis with ReactomePA
* Some code from previous chunk required
```{r, warning = FALSE, message = FALSE}
# Carry out GSEA enrichment with ReactomePA
RPA.gsea <- gsePathway(ttsigGenesEntrezGSEA, organism="human", pvalueCutoff=0.05, by="fgsea")
RPA.gsea@result$order = 1:nrow(RPA.gsea@result)
RPA.gsea.copy <- RPA.gsea

# Create heatmaps to plot pathways determined by GSEA based on similarity in composition
Group <- RPA.gsea@result

for(i in 1:nrow(RPA.gsea)){
  spliti <- strsplit(RPA.gsea@result$core_enrichment, split = "/")
  unspliti <- AnnotationDbi::select(hs,
                                    keys = as.character(spliti[[i]]),
                                    columns = "SYMBOL",
                                    keytype = "ENTREZID")
  unspliti <- unspliti[,2]
  unspliti <- paste(unspliti, collapse = "::")
  
  RPA.gsea@result$core_enrichment[i] <- unspliti
}

# Clean up the environment
rm(list = c("spliti", "unspliti", "i"))
```

# Gene-set Enrichment Analysis with fgsea
### Carry out fgsea gene-set enrichment analysis
```{r}
# Rename ranks for simplicity
ranks.gsea <- ttsigGenesEntrezGSEA
# Remove NAs
ranks.gsea <- na.omit(ranks.gsea)
# Remove elements with NA names
ranks.gsea <- ranks.gsea[!is.na(names(ranks.gsea))]
# Remove elements with duplicate names, keeping the first occurrence
ranks.gsea <- ranks.gsea[!duplicated(names(ranks.gsea))]
# Find reactome pathways
gsea.reactome <- reactomePathways(names(ranks.gsea))

# gsea
fgsea.gsea <- fgsea(gsea.reactome, ranks.gsea, maxSize = 500, minSize = 20) %>% .[order(padj),] %>% .[.$padj < 0.05,]
# create collapsed pathways
fgsea.gsea.collapsed <- collapsePathways(fgsea.gsea, gsea.reactome, stats = ranks.gsea)
```

### Output tidy tables for thesis
* Top table from limma
```{r}
tt.table <- tt
# Set rownames to blank
rownames(tt.table) <- NULL
# Remove unnecessary columns
tt.table <- tt.table %>% dplyr::select(-c("P.Value", "B"))
# Remove rows where symbol = NA
tt.table <- tt.table %>% dplyr::filter(!is.na(`Symbol`))
# Rename columns
tt.table <- dplyr::rename(tt.table,
                          "Adjusted P-value" = adj.P.Val,
                          "Average Expression" = AveExpr,
                          "log2 Fold Change" = logFC,
                          "t Statistic" = t,
                          "Gene Symbol" = Symbol)
# Reorder columns
tt.table <- tt.table %>% dplyr::select("Gene Symbol", "Adjusted P-value", "t Statistic", "Average Expression", "log2 Fold Change")
# Round numeric columns
tt.table[] <- lapply(tt.table, function(column) {
  if (is.numeric(column)) {
    as.character(pref.round(column)) # Convert to character to preserve formatting
  } else {
    column # Leave non-numeric columns unchanged
  }
})
# Save the data frame
write.csv(tt.table, file = paste0("00_output/tt.csv"), row.names = F)
```

* fgsea results
```{r}
# Replace leading Edge entrez IDs with symbols
entrez <- fgsea.gsea[["leadingEdge"]]
for(x in 1:length(entrez)){
  symbol <- AnnotationDbi::select(hs,
                                  keys = unlist(entrez[x]),
                                  columns = "SYMBOL",
                                  keytype = "ENTREZID") %>% .[,"SYMBOL"]
  fgsea.gsea[x, "leadingEdge"] <- symbol
}
# Save gsea results as table for thesis
fgsea.gsea.table <- fgsea.gsea
# Sort leadingEdge alphabetically
fgsea.gsea.table$leadingEdge <- lapply(fgsea.gsea.table$leadingEdge, sort)
# Collapse leadingEdge from a list into a vector
fgsea.gsea.table$leadingEdge <- sapply(fgsea.gsea.table$leadingEdge, function(x) paste(x, collapse = ", "))
# Convert to character
fgsea.gsea.table$leadingEdge <- as.character(fgsea.gsea.table$leadingEdge)
# Remove uneeded columns
fgsea.gsea.table <- fgsea.gsea.table[, -c("pval", "log2err", "ES", "NES")]
# Rename columns
fgsea.gsea.table <- dplyr::rename(fgsea.gsea.table,
                                  "Adjusted P-value" = padj,
                                  "Size" = size,
                                  "Leading Edge" = leadingEdge,
                                  "Reactome Pathway Term" = pathway)
# Reorder columns
fgsea.gsea.table <- fgsea.gsea.table %>% dplyr::select("Reactome Pathway Term", "Adjusted P-value", "Size", "Leading Edge")
# Sort by pathway alphabetically
fgsea.gsea.table <- fgsea.gsea.table[order(fgsea.gsea.table$`Reactome Pathway Term`), ]
# Round numeric columns
fgsea.gsea.table[] <- lapply(fgsea.gsea.table, function(column) {
  if (is.numeric(column)) {
    as.character(pref.round(column)) # Convert to character to preserve formatting
  } else {
    column # Leave non-numeric columns unchanged
  }
})
# Save as data frame
write.csv(as.data.frame(fgsea.gsea.table), file = paste0("00_output/fgsea_gsea.csv"), row.names = F)

# Extract a table of parent pathways
keep <- fgsea.gsea.collapsed$mainPathways
# Filter fgsea.gsea.table
fgsea.gsea.table.parent <- fgsea.gsea.table %>% dplyr::filter(`Reactome Pathway Term` %in% keep)
# Save as data frame
write.csv(as.data.frame(fgsea.gsea.table.parent), file = paste0("00_output/fgsea_gsea_parent.csv"), row.names = F)

# Tidy up the environment
rm(list = c("keep", "x", "symbol", "entrez"))
```

# Not sure what this section is
* Create heatmaps to plot pathways determined by GSEA based on similarity in gene composition - for each of the comparisons. These are saved in: archive\\blacklab\\KieranRedpath\\RNAseqHuman2\\analysis\\output
```{r}
genesinSets <- list()
for(i in 1:nrow(Group)){
  genesinSets[[i]] <- rGenesPath[match(Group$ID[i], names(rGenesPath))] %>% .[[1]]
  
}
names(genesinSets) <- Group$Description

# Intersections and heatmaps
ensginSigSets <- genesinSets

SetGeneInt <- matrix(data = 0, nrow = length(ensginSigSets), ncol = length(ensginSigSets))
rownames(SetGeneInt) <- colnames(SetGeneInt) <- gsub("Homo sapiens\\r: ", "", names(ensginSigSets))
for(i in 1:length(ensginSigSets)){
  for(j in 1:length(ensginSigSets)){
    Seti <- ensginSigSets[[i]]
    Setj <- ensginSigSets[[j]]
    SetGeneInt[i,j] <- length(intersect(Seti, Setj)) / length(Seti)
  }
}

# Remove rows and columns with NA's
SetGeneInt <- na.omit(SetGeneInt)

cols <- colorRampPalette(c("white", "red"))(n = 50)
ord <- as.dendrogram(hclust(dist(SetGeneInt)))
png(paste0("00_output/Gene_Set_Overlap.png"), width = 3000, height = 3000)
par(cex.main = 5, cex.lab = 3.5, cex.axis = 3.5)
heatmap.2(SetGeneInt, scale = 'none', trace = 'none', col = cols, key = TRUE,
          keysize = 1.4, density.info = "none", mar = c(75,75), cexRow = 1, cexCol = 1, cex.main = 10,
          dendrogram = 'row',
          main = "Gene Set Overlap in Genes",
          Rowv = ord, Colv = ord)
dev.off()

# Fix escape characters in pathway names for genesinSets
names(genesinSets) <- gsub("\\r", "", names(genesinSets))
```

* Compare the enriched smaller gene sets
```{r}
# Filter by size of gene set
RPA.gsea.small <- filter(RPA.gsea@result, RPA.gsea@result$setSize < 60)

# Create heatmaps to plot pathways based on similarity in composition

Group <- RPA.gsea.small
genesinSets <- list()
for(i in 1:nrow(Group)){
  genesinSets[[i]] <- rGenesPath[match(Group$ID[i], names(rGenesPath))] %>% .[[1]]
  
}
names(genesinSets) <- Group$Description

# Intersections and heatmaps
ensginSigSets <- genesinSets

SetGeneInt <- matrix(data = 0, nrow = length(ensginSigSets), ncol = length(ensginSigSets))
rownames(SetGeneInt) <- colnames(SetGeneInt) <- gsub("Homo sapiens\\r: ", "", names(ensginSigSets))
for(i in 1:length(ensginSigSets)){
  for(j in 1:length(ensginSigSets)){
    Seti <- ensginSigSets[[i]]
    Setj <- ensginSigSets[[j]]
    SetGeneInt[i,j] <- length(intersect(Seti, Setj)) / length(Seti)
  }
}

# Remove rows and columns with NA's
SetGeneInt <- na.omit(SetGeneInt)

cols <- colorRampPalette(c("white", "red"))(n = 50)
ord <- as.dendrogram(hclust(dist(SetGeneInt)))
png(paste0("00_output/Small_Gene_Set_Overlap.png"), width = 3000, height = 3000)
par(cex.main = 5, cex.lab = 3.5, cex.axis = 3.5)
heatmap.2(SetGeneInt, scale = 'none', trace = 'none', col = cols, key = TRUE,
          keysize = 1.4, density.info = "none", mar = c(75,75), cexRow = 1, cexCol = 1, cex.main = 10,
          dendrogram = 'row',
          main = "Small Gene Set Overlap in Genes",
          Rowv = ord, Colv = ord)
dev.off()

# Fix escape characters in pathway names for genesinSets
names(genesinSets) <- gsub("\\r", "", names(genesinSets))
```

* View a specific smaller pathway - can't get this to work
```{r}
# library(enrichplot)
# 
# zzz <- tt$logFC
# zzznames <- tt$Symbol
# # zzznames <- rownames(tt)
# unique(zzznames) %>% length()
# zzz <- zzz[which(!duplicated(zzznames))]
# names(zzz) <- zzznames[which(!duplicated(zzznames))]
# 
# viewPathway(pathName = "Laminin interactions", organism = "human", foldChange = zzz, keyType = "SYMBOL")
# 
# # Different method, different error
# enrichplot::gseaplot(RPA.gsea.copy, geneSetID = "Laminin interactions", by = "runningScore")
```

# Gene-set Enrichment Analysis with GO terms and clusterProfiler

* Find enriched GO terms using GSEA, and filter them by size
* Create heatmaps to plot GO terms determined by GSEA based on similarity in gene composition - for each of the comparisons. These are saved in: archive\\blacklab\\KieranRedpath\\RNAseqHuman2\\analysis\\output
```{r}
# Run GO term GSE analysis, only finding gene sets with less than 100 genes in them
GO.gsea <- gseGO(ttsigGenesEntrezGSEA, OrgDb = hs, ont = "ALL", keyType = "ENTREZID", maxGSSize = 300)

# Create a copy of the original object for plotting with after you mess around with the original for readability
GO.gsea.copy <- GO.gsea
GO.gsea@result$order = 1:nrow(GO.gsea@result)

# Simplify to remove some redundancy in GO terms (as they're tiered) - you could use this more later on
GO.gsea.simple <- simplify(GO.gsea.copy)
# emapplot(simple)
# Create Group object for heatmaps to plot pathways determined by GSEA based on similarity in composition
Group <- GO.gsea@result

# Replace ENTREZ ID's with gene symbols for readability in the result table
for(i in 1:nrow(GO.gsea)){
  spliti <- strsplit(GO.gsea@result$core_enrichment, split = "/")
  unspliti <- AnnotationDbi::select(hs,
                                    keys = as.character(spliti[[i]]),
                                    columns = "SYMBOL",
                                    keytype = "ENTREZID")
  unspliti <- unspliti[,2]
  unspliti <- paste(unspliti, collapse = "::")
  
  GO.gsea@result$core_enrichment[i] <- unspliti
}

# Create a fun little plot
ridgeplot(GO.gsea.copy) + labs(x = "enrichment distribution")
# # Try and create another fun little plot
clusterProfiler::emapplot(GO.gsea.copy, showCategory = 10)
# This just crashes
clusterProfiler::goplot(GO.gsea.copy, showCategory = 10)
plotGOgraph(GO.gsea.copy)

# Extract every gene that maps to each significant GO term, using the simplified list of GO terms
genesinSets <- mget(rownames(GO.gsea.simple@result),org.Hs.egGO2ALLEGS)
names(genesinSets) <- GO.gsea.simple@result$Description

# Intersections and heatmaps
ensginSigSets <- genesinSets

SetGeneInt <- matrix(data = 0, nrow = length(ensginSigSets), ncol = length(ensginSigSets))
rownames(SetGeneInt) <- colnames(SetGeneInt) <- gsub("Homo sapiens\\: ", "", names(ensginSigSets))
for(i in 1:length(ensginSigSets)){
  for(j in 1:length(ensginSigSets)){
    Seti <- ensginSigSets[[i]]
    Setj <- ensginSigSets[[j]]
    SetGeneInt[i,j] <- length(intersect(Seti, Setj)) / length(Seti)
  }
}

# Remove rows and columns with NA's
SetGeneInt <- na.omit(SetGeneInt)

cols <- colorRampPalette(c("white", "red"))(n = 50)
ord <- as.dendrogram(hclust(dist(SetGeneInt)))
png(paste0("00_output/GO_Term_Gene_Set_Overlap.png"), width = 3000, height = 3000)
par(cex.main = 5, cex.lab = 3.5, cex.axis = 3.5)
heatmap.2(SetGeneInt, scale = 'none', trace = 'none', col = cols, key = TRUE,
          keysize = 1.4, density.info = "none", mar = c(75,75), cexRow = 1, cexCol = 1, cex.main = 10,
          dendrogram = 'row',
          main = "GO Term Overlap in Genes",
          Rowv = ord, Colv = ord)
dev.off()
```

# Over-representation Analysis with Reactome Pathways and goseq

* Identify enriched Reactome pathways with the goseq package, with significant genes as adj. p-value \< 0.05, and Wallenius method gene length correction
* Carry out the same analysis but with the hypergeometric method
```{r, include = FALSE}
# goseq processing, where gene2cat is an object mapping gene names to Reactome pathway terms
pwfReactome <- nullp(plotGenes, 'hg19', id = "knownGene")
Reactome.wall <- goseq(pwfReactome, gene2cat = rGeneByPathFinal)
Reactome.wall$padj <- p.adjust(Reactome.wall$over_represented_pvalue, method = "fdr")

# Add pathway information, make it more readable, and round values
Reactome.wall$Pathway <- gsub("Homo sapiens: ", "", rPathName[match(Reactome.wall$category, names(rPathName))])
Reactome.wall[,2:6] <- round(as.numeric(unlist(Reactome.wall[,2:6])), digits=4)

# Filter for significance (adj p-value < 0.05)
# Reactome.wall <- filter(Reactome.wall, Reactome.wall$padj < 0.05)
# Or with FDR adjust threshold 0.1 or 0.2...
# Reactome.wall <- filter(Reactome.wall, Reactome.wall$padj < 0.2)

# Add a column containing all of the genes in a reactome pathway

# Carry out this analysis again,but using the hypergeometric method (i.e. no length-correction). If there isn't too much difference, this can be validation for using GSEA instead of DE to identify enriched processes.
# goseq processing, where gene2cat is an object mapping gene names to Reactome pathway terms
pwfReactome <- nullp(plotGenes, 'hg19', id = "knownGene")
Reactome.hyper <- goseq(pwfReactome, gene2cat = rGeneByPathFinal, method = "Hypergeometric")
Reactome.hyper$padj <- p.adjust(Reactome.hyper$over_represented_pvalue, method = "fdr")

# Add pathway information, make it more readable, and round values
Reactome.hyper$Pathway <- gsub("Homo sapiens: ", "", rPathName[match(Reactome.hyper$category, names(rPathName))])
Reactome.hyper[,2:6] <- round(as.numeric(unlist(Reactome.hyper[,2:6])), digits=4)

# Filter for significance (adj p-value < 0.05)
Reactome.hyper <- filter(Reactome.hyper, Reactome.hyper$padj < 0.05)
```

* Add a column to reactome.wall containing all DE genes in cat 
```{r}
# Create a tool for gene labels
GeneLabelTool <- dplyr::pull(tt, Symbol)
GeneLabelTool <- AnnotationDbi::select(hs,
                                       keys = GeneLabelTool,
                                       columns = c("ENSEMBL", "ENTREZID", "SYMBOL"),
                                       keytype = "SYMBOL")

# Creates a list of significant genes for each goseq pathway, converts them to symbol ID's. Also does the same for all the genes in each pathway and adds the information to "Reactome.wall".
SiggenesinPaths <-list()
for(i in 1:nrow(Reactome.wall)){
  SiggenesinPaths[[i]] <- rGenesPath[match(Reactome.wall$category[i], names(rGenesPath))] %>% 
    .[[1]] %>% 
    intersect(., rownames(pwfReactome)[pwfReactome$DEgenes==1])
}

genesinPaths <- list()
for(i in 1:nrow(Reactome.wall)){
  genesinPaths[[i]] <- rGenesPath[match(Reactome.wall$category[i], names(rGenesPath))] %>% 
    .[[1]] %>% 
    intersect(., rownames(pwfReactome)[pwfReactome$DEgenes==1 | pwfReactome$DEgenes==0])
}
SigsymbolsinPaths <- lapply(SiggenesinPaths, function(x) GeneLabelTool$SYMBOL[na.omit(match(x, GeneLabelTool$ENTREZID))] )
symbolsinPaths <- lapply(genesinPaths, function(x) GeneLabelTool$SYMBOL[na.omit(match(x, GeneLabelTool$ENTREZID))] )

# Save the object that's loaded in to calculate metagenes.
ensginPaths <- lapply(genesinPaths, function(x) GeneLabelTool$ENSEMBL[na.omit(match(x, GeneLabelTool$ENTREZID))] )
# saveRDS(ensginPaths, file = "00_output/Ensembl_ID_in_Paths.Rds")

# Attach a string of significant genes and a string of all genes in each reactome pathway to that pathway
SiggenesStick <- lapply(SigsymbolsinPaths, function(x) paste0(x, collapse="::", sep="")) %>% unlist()
Reactome.wall$DEgenesInCat <- SiggenesStick
genesStick <- lapply(symbolsinPaths, function(x) paste0(x, collapse="::", sep="")) %>% unlist()
Reactome.wall$genesInCat <- genesStick

# Alter various names in the data.frame for readability. Can remove this if you need to
# Reactome.wall <- lapply(Reactome.wall, gsub, pattern='/', replacement=' ') %>% as.data.frame()
# Reactome.wall$Pathway <- lapply(Reactome.wall$Pathway, gsub, pattern=':', replacement='-')

# Fix class of Reactome.wall$numInCat so it can be filtered on
Reactome.wall$numInCat <- as.numeric(Reactome.wall$numInCat)
# Filter out a bunch of pathways with higher p values
Reactome.wall <- filter(Reactome.wall, Reactome.wall$padj < 0.2)
```

*  Compare the number of significantly enriched small pathways
```{r}
# Compare the number of significantly enriched pathways with or without length-correction
venn(list(Wallenius = Reactome.wall$Pathway, Hypergeometric = Reactome.hyper$Pathway))

# Check size of reactome pathways
sort(Reactome.wall$numInCat, decreasing=TRUE) %>% barplot(., ylab="Total genes in reactome pathway")

# Filter to remove very large Reactome pathways
Reactome.wall.small <- Reactome.wall
Reactome.wall.small <- filter(Reactome.wall.small, Reactome.wall.small$numInCat < 100)

# Create heatmaps to plot pathways based on similarity in composition

Group <- Reactome.wall.small
genesinPaths <- list()
for(i in 1:nrow(Group)){
  genesinPaths[[i]] <- rGenesPath[match(Group$category[i], names(rGenesPath))] %>% .[[1]]
  
}
names(genesinPaths) <- Group$Pathway

# Intersections and heatmaps
ensginSigPaths <- genesinPaths

PathGeneInt <- matrix(data = 0, nrow = length(ensginSigPaths), ncol = length(ensginSigPaths))
rownames(PathGeneInt) <- colnames(PathGeneInt) <- names(ensginSigPaths)
rownames(PathGeneInt) <- colnames(PathGeneInt) <- gsub("Homo sapiens\\r: ", "", names(ensginSigPaths))
for(i in 1:length(ensginSigPaths)){
  for(j in 1:length(ensginSigPaths)){
    Pathi <- ensginSigPaths[[i]]
    Pathj <- ensginSigPaths[[j]]
    PathGeneInt[i,j] <- length(intersect(Pathi, Pathj)) / length(Pathi)
  }
}

cols <- colorRampPalette(c("white", "red"))(n = 50)
ord <- as.dendrogram(hclust(dist(PathGeneInt)))
png(paste0("00_output/Small_Reactome_Pathway_Overlap.png"), width = 3000, height = 3000)
par(cex.main = 5, cex.lab = 3.5, cex.axis = 3.5)
heatmap.2(PathGeneInt, scale = 'none', trace = 'none', col = cols, key = TRUE,
          keysize = 1.4, density.info = "none", mar = c(75,75), cexRow = 1, cexCol = 1, cex.main = 10,
          dendrogram = 'row',
          main = "Small Reactome Pathway Overlap in Genes", 
          Rowv = ord, Colv = ord)
dev.off()
```

* Create a heatmap to plot pathways determined by pathway enrichment based on similarity in gene composition. These are saved in: archive\\blacklab\\KieranRedpath\\RNAseqHuman2\\analysis\\output
```{r}
# Create heatmaps to plot pathways based on similarity in composition

Group <- Reactome.wall
genesinPaths <- list()
for(i in 1:nrow(Group)){
  genesinPaths[[i]] <- rGenesPath[match(Group$category[i], names(rGenesPath))] %>% .[[1]]
  
}
names(genesinPaths) <- Group$Pathway

# Intersections and heatmaps
ensginSigPaths <- genesinPaths

PathGeneInt <- matrix(data = 0, nrow = length(ensginSigPaths), ncol = length(ensginSigPaths))
rownames(PathGeneInt) <- colnames(PathGeneInt) <- names(ensginSigPaths)
rownames(PathGeneInt) <- colnames(PathGeneInt) <- gsub("Homo sapiens\\r: ", "", names(ensginSigPaths))
for(i in 1:length(ensginSigPaths)){
  for(j in 1:length(ensginSigPaths)){
    Pathi <- ensginSigPaths[[i]]
    Pathj <- ensginSigPaths[[j]]
    PathGeneInt[i,j] <- length(intersect(Pathi, Pathj)) / length(Pathi)
  }
}

cols <- colorRampPalette(c("white", "red"))(n = 50)
ord <- as.dendrogram(hclust(dist(PathGeneInt)))
png(paste0("00_output/Pathway_Overlap.png"), width = 3000, height = 3000)
par(cex.main = 5, cex.lab = 3.5, cex.axis = 3.5)
heatmap.2(PathGeneInt, scale = 'none', trace = 'none', col = cols, key = TRUE,
          keysize = 1.4, density.info = "none", mar = c(75,75), cexRow = 1, cexCol = 1, cex.main = 10,
          dendrogram = 'row',
          main = "Reactome Pathway Overlap in Genes", 
          Rowv = ord, Colv = ord)
dev.off()
```

# Compare ReactomePA and goseq Hypergeometric Over-represenation Analysis Results
*  Compare the overlap in pathways between ReactomePA and goseq hypergeometric pathway enrichment
```{r}
# Compare pathway output from reactomePA (hypergeometric) and goseq(hypergeometric)
# Pull out just the useful dataframes from RPA.hyper, so that it matches RPA.goseq

RPA.hyper2 <- RPA.hyper@result
names(RPA.hyper2)[2] <- "Pathway"
RPA.hyper2 <- RPA.hyper2 %>% filter(p.adjust < 0.05)

venn(list(RPA.hyper = RPA.hyper2$Pathway, Reactome.hyper = Reactome.hyper$Pathway))
```
