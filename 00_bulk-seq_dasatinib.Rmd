---
title: "Bulk Sequencing Analysis"
output: html_document
---

# Setup and QC
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

### Load Packages
```{r}
# Not all of these are used for thesis stuff, many are only for exploratory analyses
library(dplyr)
library(limma)
library(edgeR)
library(gplots)
library(goseq)
library(AnnotationDbi)
library(reactome.db)
library(org.Hs.eg.db)
library(ggplot2)
library(ggvenn)
library(ReactomePA)
library(stringr)
library(clusterProfiler) # Overwrites select and filter, but they're both copied from dplyr apparently
library(enrichplot)
library(fgsea)

# Load human genome IDs
hs <- org.Hs.eg.db

# Set random seed for reproducibility
set.seed(42)
```

### Define variables and function for rounding thesis tables
```{r}
# Round numeric columns to 3 sig.digits
sig.digits <- 3
# Create a function that determines when to use which type of rounding in a data.frame
pref.round <- function(x) {
  if (is.numeric(x)) {
    ifelse(
      x %% 1 == 0,  # Skip rounding for whole numbers
      x,
      ifelse(
        abs(x) < 0.1,  # Use scientific notation for abs(x) < 0.1
        formatC(x, format = "e", digits = sig.digits),
        formatC(x, format = "f", digits = sig.digits)  # Use fixed-point otherwise
      )
    )
  } else {
    x  # Return non-numeric values as-is
  }
}
```


### Process counts data
```{r}
# # Load data (this file is not currently in the project, so the processed copy of fcData is provided instead as a .RDS file at the end of this chunk)
# # fcData <- read.table("../counts/human-counts.txt", header=TRUE)
# 
# # Inspect data
# # fcData %>% head()
# # dim(fcData)
# # names(fcData)
# 
# # Rename samples to sample number for readability
# names(fcData)[7:16] <- c(1:6, 13:16)
# # Remove columns for samples 13:16 for this analysis
# fcData <- fcData[, 1:12]

# Load file, processed as above
fcData <- readRDS("data/bulk-seq_dasatinib_annotated.RDS")
```

### Separate and inspect count data
* Inspect counts
* Inspect counts per sample
```{r, echo = TRUE}
# Inspect counts
counts <- fcData[7:12]
rownames(counts) <- fcData$Geneid
head(counts)

# Make a duplicate for comparison
countsRaw <- counts

# Inspect counts per sample
colSums(counts) %>% barplot(., las=3, ylab="Reads mapped per sample")
# Fairly similar
```

### Counts density and distribution
* Visualise counts density and distribution. There are many low counts and counts of 0
* How many counts of 0 are present in each sample, and each sample as a proportion? Roughly 60% of count data in each sample are 0's
* What proportion of genes have no count data? 27% of genes have no count data in any samples
```{r, echo = TRUE}
# Visualise counts density and distribution
plot(density(log(counts[,1]+0.5)), ylim=c(0,0.5))
for(i in 1:6) lines(density(log(counts[,i]+0.5)), col=i)
boxplot(log(as.matrix(counts)+0.5) ~ col(as.matrix(counts)))
# there are many low counts and counts of 0

# How many counts of 0 are present in each sample?
colSums(counts==0)
# How many counts of 0 are present in each sample as a proportion?
colSums(counts==0)/nrow(counts)
# Roughly 60% of count data in each sample are 0's
# What proportion of genes have no count data?
sum(rowSums(counts==0)==0)/nrow(counts)
# 30% of genes have no count data in any samples
```

### Filter counts to increase power
* Create design matrix to compare the three Das samples to DMSO
* Filter out genes with low counts
```{r}
# Create a design matrix that classifies samples based on their treatment and compares them all to DMSO as a baseline
trt <- rep(letters[1:2], each = 3)
design <- model.matrix(~trt)

# Filter out genes with very low counts across all samples - using defaults. STICK WITH LESS STRICT FILTERS cause you don't want to throw too much stuff out.
countskeep <- filterByExpr(counts, design=design, min.count = 10, min.total.count = 15, min.prop = 0.7)
sum(countskeep == TRUE)
sum(countskeep == FALSE)

counts <- counts[countskeep,]
```

# Differential Gene Expression Analysis

### Design and normalisation
```{r}
# Create design matrix with limma
dge <- DGEList(counts=counts) 
dge <- calcNormFactors(dge)
# Analyse logCPM
logCPM <- cpm(dge, log=TRUE, prior.count = 1)
head(logCPM, 3)

# Voom to prepare for linear modelling
v <- voom(dge, design, plot=TRUE)
```

### Explore alignment between samples
* Plot V\$E for samples in a treatment group against each other to see how much they agree
```{r}
# Plot v$E for samples in a treatment group against each other to see how much they agree

# Compare samples to each other
E <- as.data.frame(v$E)
colnames(E) <- c("DMSO_A1", "DMSO_A2", "DMSO_A3", "Das_A4", "Das_A5", "Das_A6")

# Plot the first two DMSO samples against each other
cor.test(E[,1], E[,2], method = "spearman") %>% print(.)
print(
  ggplot(E, aes(x = E[,1], y = E[,2])) +
    geom_point() +
    xlab(colnames(E)[1]) +
    ylab(colnames(E)[2])
)

# Plot the first two Dasatinib samples against each other
cor.test(E[,4], E[,5], method = "spearman") %>% print(.)
print(
  ggplot(E, aes(x = E[,4], y = E[,5])) +
    geom_point() +
    xlab(colnames(E)[4]) +
    ylab(colnames(E)[5])
)
```

* Compare all Das samples to DMSO
```{r, include = FALSE}
# Compare all Das samples to DMSO_A1
for(s in 4:6){
  cor.test(E[,1], E[,s], method = "spearman") %>% print(.)
  print(
    ggplot(E, aes(x = E[,1], y = E[,s])) +
      geom_point() +
      xlab(colnames(E)[1]) +
      ylab(colnames(E)[s])
  )
  ggsave(paste0("00_output/", colnames(E)[1], "_Vs_", colnames(E)[s], ".png"))
}

# Compare all Das samples to DMSO_A2
for(s in 4:6){
  cor.test(E[,2], E[,s], method = "spearman") %>% print(.)
  print(
    ggplot(E, aes(x = E[,2], y = E[,s])) +
      geom_point() +
      xlab(colnames(E)[2]) +
      ylab(colnames(E)[s])
  )
  ggsave(paste0("00_output/", colnames(E)[2], "_Vs_", colnames(E)[s], ".png"))
}

# Compare all Das samples to DMSO_A3
for(s in 4:6){
  cor.test(E[,3], E[,s], method = "spearman") %>% print(.)
  print(
    ggplot(E, aes(x = E[,3], y = E[,s])) +
      geom_point() +
      xlab(colnames(E)[3]) +
      ylab(colnames(E)[s])
  )
  ggsave(paste0("00_output/", colnames(E)[3], "_Vs_", colnames(E)[s], ".png"))
}
```
Output is suppressed, but Das is very similar to DMSO, (in fact almost identical).

* Do the same again, but this time without having filtered counts
* First, samples against each other (unfiltered) - output is supressed
```{r, include = FALSE}
##### Try the same thing but with every single gene, before filtering counts:
# Create design matrix with limma
dge.RAW <- DGEList(counts=countsRaw) 
dge.RAW <- calcNormFactors(dge.RAW)
# Analyse logCPM
logCPM.RAW <- cpm(dge.RAW, log=TRUE, prior.count=3)
head(logCPM.RAW, 3)

# Voom to prepare for linear modelling
v.RAW <- voom(dge.RAW, design, plot=TRUE)

E.RAW <- as.data.frame(v.RAW$E)
colnames(E.RAW) <- c("DMSO_A1", "DMSO_A2", "DMSO_A3", "Das_A4", "Das_A5", "Das_A6")

# Plot the first two DMSO samples against each other
cor.test(E.RAW[,1], E.RAW[,2], method = "spearman") %>% print(.)
print(
  ggplot(E.RAW, aes(x = E.RAW[,1], y = E.RAW[,2])) +
    geom_point() +
    xlab(colnames(E.RAW)[1]) +
    ylab(colnames(E.RAW)[2])
)

# Plot the first two Dasatinib samples against each other
cor.test(E.RAW[,4], E.RAW[,5], method = "spearman") %>% print(.)
print(
  ggplot(E.RAW, aes(x = E.RAW[,4], y = E.RAW[,5])) +
    geom_point() +
    xlab(colnames(E.RAW)[4]) +
    ylab(colnames(E.RAW)[5])
)
```

* Next, all Das samples against DMSO_A1, DMSO_A2, and DMSO_A3 (unfiltered)
```{r}
# Compare all Das samples to DMSO_A1
for(s in 4:6){
  cor.test(E.RAW[,1], E.RAW[,s], method = "spearman") %>% print(.)
  print(
    ggplot(E.RAW, aes(x = E.RAW[,1], y = E.RAW[,s])) +
      geom_point() +
      xlab(colnames(E.RAW)[1]) +
      ylab(colnames(E.RAW)[s])
  )
  ggsave(paste0("00_output/unfiltered_", colnames(E.RAW)[1], "_Vs_", colnames(E.RAW)[s], ".png"))
}

# Compare all Das samples to DMSO_A2
for(s in 4:6){
  cor.test(E.RAW[,2], E.RAW[,s], method = "spearman") %>% print(.)
  print(
    ggplot(E.RAW, aes(x = E.RAW[,2], y = E.RAW[,s])) +
      geom_point() +
      xlab(colnames(E.RAW)[2]) +
      ylab(colnames(E.RAW)[s])
  )
  ggsave(paste0("00_output/unfiltered_", colnames(E.RAW)[2], "_Vs_", colnames(E.RAW)[s], ".png"))
}

# Compare all Das samples to DMSO_A3
for(s in 4:6){
  cor.test(E.RAW[,3], E.RAW[,s], method = "spearman") %>% print(.)
  print(
    ggplot(E.RAW, aes(x = E.RAW[,3], y = E.RAW[,s])) +
      geom_point() +
      xlab(colnames(E.RAW)[3]) +
      ylab(colnames(E.RAW)[s])
  )
  ggsave(paste0("00_output/unfiltered_", colnames(E.RAW)[3], "_Vs_", colnames(E.RAW)[s], ".png"))
}
```
The correlation is slightly less strong amongst these samples, but still basically identical

# Fit the linear model and create toptable
* Define DE genes and create the toptable for each comparison
```{r}
# Create linear matrix
fit <- lmFit(v, design) %>% eBayes(.)
# Create a single toptable, as the only  comparison is all 3 DMSO samples vs all 3 Das samples
tt <- topTable(fit, coef = 2, n = nrow(counts))

# Limma uses alphabetical order: the genes with a positive logFC are more expressed in the group that is later alphabetically
```

# Annotate tt and create filtered copies for downstream analyses
* Filter genes a little bit based on abs(FC) and significant adj. p-values
* Add gene symbols to toptable
* Creates outputs: ttsigFC (adj. p-value \< 0.05, abs(logFC) \>= 2) ttsigwall (adj. p-value \< 0.05)

```{r}
# Use this information to identify genes with high abs(FC) and significant adj p-values
# Create list of gene IDs, pulling from toptable
GeneKey <- AnnotationDbi::select(hs,
                                 keys=fcData$Geneid,
                                 columns = c("ENSEMBL", "SYMBOL", "ENTREZID"),
                                 keytype = "ENSEMBL")

# Add gene symbols to toptable
tt$Symbol <- GeneKey$SYMBOL[match(rownames(tt), GeneKey$ENSEMBL)]

# Tidy up the environment
rm(list = c("GeneKey"))

# This is used for GOSEQ reactome analysis:
ttsigFC <- filter(tt, tt$adj.P.Val < 0.2 & abs(tt$logFC) >= 1)
# Filter genes for significance - see what happens if you put in a threshold of 0.1:
ttsigwall <- filter(tt, tt$adj.P.Val < 0.2)
# ttsigwall <- filter(tt, tt$adj.P.Val < 0.1)
```

# Over-representation Analysis with goseq

### Gene ontolgy enrichment analysis with goseq
* Assign significance to genes from toptable for goseq GO term analysis
* Carry out GO analysis with Wallenius method (correction for gene length)
* Carry out GO analysis with hypergeometric method (no correction for gene lenth)
```{r, include = FALSE}
# Assign significance to genes from toptables
# Only on p-value
genes <- ifelse(tt$adj.P.Val < 0.2, 1, 0)
names(genes) <- rownames(tt)
print(table(genes))

# goseq processing for GO terms
pwf <- nullp(genes, genome="hg19", id="ensGene")
GO.wall <- goseq(pwf, genome="hg19", id="ensGene")
# Adjust p-values
GO.wall$padj <- p.adjust(GO.wall$over_represented_pvalue, method="fdr")
GO.wall <- filter(GO.wall, GO.wall$padj < 0.05)

# goseq processing for GO terms
pwf <- nullp(genes, genome="hg19", id="ensGene")
GO.hyper <- goseq(pwf, genome="hg19", id="ensGene", method="Hypergeometric")
# Adjust p-values
GO.hyper$padj <- p.adjust(GO.hyper$over_represented_pvalue, method="fdr")
GO.hyper <- filter(GO.hyper, GO.hyper$padj < 0.05)
```

* Compare the number of significant GO terms with/without length-correction
```{r}
# Compare the number of significant GO terms with or without length-correction
venn(list(Wallenius = GO.wall$term, Hypergeometric = GO.hyper$term))

# Check size of GO terms
sort(GO.wall$numInCat, decreasing=TRUE) %>% barplot(., ylab="Total genes in reactome pathway")
```

# Reactome Pathway Analysis with ReactomePA and goseq
* Define significant and non-significant genes for Reactome pathway analysis
```{r}
# Convert gene names to entrez IDs for mapping to reactome

# Extract pathway names and human-only pathways from reactome
rName <- as.list(reactomePATHNAME2ID)
rPathName <- as.list(reactomePATHID2NAME)
rName <- rName[grep("Homo sapiens", names(rName))]
# Extract pathway genes from reactome
rGenes <- as.list(reactomePATHID2EXTID)
rGenesPath <- rGenes[match(rName, names(rGenes))]
rGenesPath <- lapply(rGenesPath, unique)
rGeneByPath <- as.list(reactomeEXTID2PATHID)
rPathName <- as.list(reactomePATHID2NAME)

# Separate significant and non-significant genes for reactome analysis
ttGenesEntrez <- AnnotationDbi::select(hs,
                                       keys = as.character(na.omit(rownames(tt))),
                                       columns = "ENTREZID",
                                       keytype = "ENSEMBL")

ttsigwallGenesEntrez <- AnnotationDbi::select(hs,
                                              keys = as.character(na.omit(rownames(ttsigwall))),
                                              columns = "ENTREZID",
                                              keytype = "ENSEMBL")

# Define which of your genes are in the reactome database 
allGenes <- intersect( ttGenesEntrez$ENTREZID, unique(unlist(rGenesPath)) )

sigGenes <- intersect( ttsigwallGenesEntrez$ENTREZID, unique(unlist(rGenesPath)) )

# Define which genes are significant
plotGenes <- rep(0, length(allGenes))
names(plotGenes) <- allGenes
plotGenes[match(sigGenes, names(plotGenes))] <- 1
print(table(plotGenes))

# Which genes are relevant to the dataset?
mt <- match(allGenes, names(rGeneByPath))
rGeneByPathFinal <- lapply(rGeneByPath[mt], function(x) intersect(x, names(rGenesPath)))
```

### Use ReactomePA to identify enriched reactome pathways without length-correction, and prepare for GSEA
* Use ReactomePA to identify enriched reactome pathways with gene significance defined as adj. p-value < 0.05, with the hypergeometric method
* Create list of genes ranked by t statistic for GSEA
```{r}
# Create something to work off
# Filter by adj p-value
# For RPA.hyper
ttsig <- filter(tt, tt$adj.P.Val < 0.2) # & abs(tt$logFC) >= 2)
ttsigGenesEntrez <- AnnotationDbi::select(hs, 
                                          keys = as.character(na.omit(rownames(ttsig))),
                                          columns = "ENTREZID",
                                          keytype = "ENSEMBL")

# Filter out duplicate matches so t statistic can be added
ttsigGenesEntrez <- ttsigGenesEntrez[match(rownames(ttsig), ttsigGenesEntrez$ENSEMBL), ]
# Add t statistic column for ranking
ttsigGenesEntrez$t <- ttsig$t
# Rank by t statistic
ttsigGenesEntrez <- ttsigGenesEntrez[order(ttsigGenesEntrez$t), ]

# For RPA.gsea
ttsig.gsea <- tt #filter(tt, tt$adj.P.Val < 0.05 & abs(tt$logFC) >= 2)
ttsigGenesEntrez.gsea <- AnnotationDbi::select(hs, 
                                               keys = as.character(na.omit(rownames(ttsig.gsea))),
                                               columns = "ENTREZID",
                                               keytype = "ENSEMBL")
# Filter out duplicate matches so t statistic can be added
ttsigGenesEntrez.gsea <- ttsigGenesEntrez.gsea[match(rownames(ttsig.gsea), ttsigGenesEntrez.gsea$ENSEMBL), ]
# Add t statistic column for ranking
ttsigGenesEntrez.gsea$t <- ttsig.gsea$t
# Rank by t statistic
ttsigGenesEntrez.gsea <- ttsigGenesEntrez.gsea[order(ttsigGenesEntrez.gsea$t), ]
# Cut down to just entrez IDs and t stat for gsePathway in an ordered, named numeric vector
ttsigGenesEntrezGSEA <- ttsigGenesEntrez.gsea$t
names(ttsigGenesEntrezGSEA) <- ttsigGenesEntrez.gsea$ENTREZID
ttsigGenesEntrezGSEA <- sort(ttsigGenesEntrezGSEA, decreasing = TRUE)

# Reactome pathway enrichment with default, hypergeometric method
RPA.hyper <- enrichPathway(gene=ttsigGenesEntrez$ENTREZID, organism="human", pvalueCutoff=0.05, readable=T)
### At the end of this document, compare these to results from goseq (hypergeometric)
```

### Gene-set Enrichment Analysis with ReactomePA
* Some code from previous chunk required
```{r, warning = FALSE, message = FALSE}
# Carry out GSEA enrichment with ReactomePA
RPA.gsea <- gsePathway(ttsigGenesEntrezGSEA, organism="human", pvalueCutoff=0.05, by="fgsea")
RPA.gsea@result$order = 1:nrow(RPA.gsea@result)
RPA.gsea.copy <- RPA.gsea

# Create heatmaps to plot pathways determined by GSEA based on similarity in composition
Group <- RPA.gsea@result

for(i in 1:nrow(RPA.gsea)){
  spliti <- strsplit(RPA.gsea@result$core_enrichment, split = "/")
  unspliti <- AnnotationDbi::select(hs,
                                    keys = as.character(spliti[[i]]),
                                    columns = "SYMBOL",
                                    keytype = "ENTREZID")
  unspliti <- unspliti[,2]
  unspliti <- paste(unspliti, collapse = "::")
  
  RPA.gsea@result$core_enrichment[i] <- unspliti
}

# Clean up the environment
rm(list = c("spliti", "unspliti", "i"))
```

# Gene-set Enrichment Analysis with fgsea
### Carry out fgsea gene-set enrichment analysis
```{r}
# Rename ranks for simplicity
ranks.gsea <- ttsigGenesEntrezGSEA
# Remove NAs
ranks.gsea <- na.omit(ranks.gsea)
# Remove elements with NA names
ranks.gsea <- ranks.gsea[!is.na(names(ranks.gsea))]
# Remove elements with duplicate names, keeping the first occurrence
ranks.gsea <- ranks.gsea[!duplicated(names(ranks.gsea))]
# Find reactome pathways
gsea.reactome <- reactomePathways(names(ranks.gsea))

# gsea
fgsea.gsea <- fgsea(gsea.reactome, ranks.gsea, maxSize = 500, minSize = 20) %>% .[order(padj),] %>% .[.$padj < 0.05,]
# create collapsed pathways
fgsea.gsea.collapsed <- collapsePathways(fgsea.gsea, gsea.reactome, stats = ranks.gsea)
```

### Output tidy tables for thesis
* Top table from limma
```{r}
tt.table <- tt
# Set rownames to blank
rownames(tt.table) <- NULL
# Remove unnecessary columns
tt.table <- tt.table %>% dplyr::select(-c("P.Value", "B"))
# Remove rows where symbol = NA
tt.table <- tt.table %>% dplyr::filter(!is.na(`Symbol`))
# Rename columns
tt.table <- dplyr::rename(tt.table,
                          "Adjusted P-value" = adj.P.Val,
                          "Average Expression" = AveExpr,
                          "log2 Fold Change" = logFC,
                          "t Statistic" = t,
                          "Gene Symbol" = Symbol)
# Reorder columns
tt.table <- tt.table %>% dplyr::select("Gene Symbol", "Adjusted P-value", "t Statistic", "Average Expression", "log2 Fold Change")
# Round numeric columns
tt.table[] <- lapply(tt.table, function(column) {
  if (is.numeric(column)) {
    as.character(pref.round(column)) # Convert to character to preserve formatting
  } else {
    column # Leave non-numeric columns unchanged
  }
})
# Save the data frame
write.csv(tt.table, file = paste0("00_output/tt.csv"), row.names = F)
```

* fgsea results
```{r}
# Replace leading Edge entrez IDs with symbols
entrez <- fgsea.gsea[["leadingEdge"]]
for(x in 1:length(entrez)){
  symbol <- AnnotationDbi::select(hs,
                                  keys = unlist(entrez[x]),
                                  columns = "SYMBOL",
                                  keytype = "ENTREZID") %>% .[,"SYMBOL"]
  fgsea.gsea[x, "leadingEdge"] <- symbol
}
# Save gsea results as table for thesis
fgsea.gsea.table <- fgsea.gsea
# Sort leadingEdge alphabetically
fgsea.gsea.table$leadingEdge <- lapply(fgsea.gsea.table$leadingEdge, sort)
# Collapse leadingEdge from a list into a vector
fgsea.gsea.table$leadingEdge <- sapply(fgsea.gsea.table$leadingEdge, function(x) paste(x, collapse = ", "))
# Convert to character
fgsea.gsea.table$leadingEdge <- as.character(fgsea.gsea.table$leadingEdge)
# Remove uneeded columns
fgsea.gsea.table <- fgsea.gsea.table[, -c("pval", "log2err", "ES", "NES")]
# Rename columns
fgsea.gsea.table <- dplyr::rename(fgsea.gsea.table,
                                  "Adjusted P-value" = padj,
                                  "Size" = size,
                                  "Leading Edge" = leadingEdge,
                                  "Reactome Pathway Term" = pathway)
# Reorder columns
fgsea.gsea.table <- fgsea.gsea.table %>% dplyr::select("Reactome Pathway Term", "Adjusted P-value", "Size", "Leading Edge")
# Sort by pathway alphabetically
fgsea.gsea.table <- fgsea.gsea.table[order(fgsea.gsea.table$`Reactome Pathway Term`), ]
# Round numeric columns
fgsea.gsea.table[] <- lapply(fgsea.gsea.table, function(column) {
  if (is.numeric(column)) {
    as.character(pref.round(column)) # Convert to character to preserve formatting
  } else {
    column # Leave non-numeric columns unchanged
  }
})
# Save as data frame
write.csv(as.data.frame(fgsea.gsea.table), file = paste0("00_output/fgsea_gsea.csv"), row.names = F)

# Extract a table of parent pathways
keep <- fgsea.gsea.collapsed$mainPathways
# Filter fgsea.gsea.table
fgsea.gsea.table.parent <- fgsea.gsea.table %>% dplyr::filter(`Reactome Pathway Term` %in% keep)
# Save as data frame
write.csv(as.data.frame(fgsea.gsea.table.parent), file = paste0("00_output/fgsea_gsea_parent.csv"), row.names = F)

# Tidy up the environment
rm(list = c("keep", "x", "symbol", "entrez"))
```
