---
title: "Single-cell Sequencing Data from Dasatinib Treated Mice"
author: "Kieran Redpath"
date: "20/03/2025"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load packages
```{r, warning=FALSE, message =FALSE}
# General
library(dplyr)
# For single cell analysis
library(Seurat)
library(ggplot2)
library(patchwork)
library(celldex)
library(SingleR)
library(scater)
# For clustering analysis
library(clustree)
# For sc-type cell type annotation
library(HGNChelper)
library(openxlsx)
# sc-type functions from GitHub
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R");
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/auto_detect_tissue_type.R")
# For plotting sc-type scores
library("ggraph")
library("igraph")
library("tidyverse")
library("data.tree")
# For differential expression analysis
library(limma)
# For identifying doublets in data
library(DoubletFinder)
# For fgsea
library(fgsea)
library(data.table)
library(org.Mm.eg.db)
# Load mm genome for annotation
mm <- org.Mm.eg.db
```

# Load data
```{r}
das.dat <- readRDS("~/R/PhD_Thesis_Chapter_4/data/scDrugMiceDas_annotated.RDS")
```

# Quality control
```{r, warning=FALSE}
# Examine proportion of mitochondrial features, as well as n features and counts per sample.
das.dat[["percent.mt"]] <- PercentageFeatureSet(das.dat, pattern = "^mt-")
VlnPlot(das.dat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
# there are varying proportions of mt genes across samples

# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot.counts.vs.features <- FeatureScatter(das.dat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot.counts.vs.features

# This is adapted from the seurat tutorial with the goal of filtering out doublets and other low quality cells
high.percent.mt <- ifelse(das.dat@meta.data[["percent.mt"]] < 10, TRUE, FALSE)
table(high.percent.mt)
# This would exclude xxx cells based on mtDNA percentage
# Cutoff being used
low.high.features <- ifelse(das.dat@meta.data[["nFeature_RNA"]] > 200, TRUE, FALSE)
table(low.high.features)
# This would exclude xxx cells based on nFeatures
# Cutoff being used
low.high.counts <- ifelse(das.dat@meta.data[["nCount_RNA"]] < 50000, TRUE, FALSE)
table(low.high.counts)
# This would exclude xxx cells based on nCounts

# On the following plot, many of the cells with very high proportions of mtDNA have very few features, indicating that they aren't good quality
plot.features.vs.percent.mt <- FeatureScatter(das.dat, feature1 = "nFeature_RNA", feature2 = "percent.mt")
plot.features.vs.percent.mt

# Try and plot some of these thresholds on the data to see what you're removing:
# Add high percent mt information to metadata
das.dat@meta.data[["high.percent.mt"]] <- high.percent.mt
# Plot percent mt against total counts
ggplot(das.dat@meta.data,  
       aes(x = nCount_RNA, y = percent.mt, color = high.percent.mt)) +
  geom_point() +
  labs(y = "Percentage mitochondrial transcripts", x = "Counts", title = "Mitochondrial transcripts")

# Mitochondrial Counts
# Create a new column to classify points above/below the abline
das.dat@meta.data$above_abline_mt <- ifelse(das.dat@meta.data$percent.mt > 10, "Above", "Below")
percent.mt.plot <- ggplot(das.dat@meta.data,  
                          aes(x = samp.ident.desc, y = percent.mt, color = samp.ident.desc)) +
  geom_jitter(aes(shape = above_abline_mt)) +  # Change shape based on condition
  geom_violin() +
  geom_abline(intercept = 10, slope = 0, color = "black", lty = 2) +
  labs(y = "Mitochondrial Counts (%)", x = NULL, title = NULL) +
  scale_shape_manual(values = c("Above" = 4, "Below" = 16)) +  # Crosses for above, circles for below
  theme_minimal() + 
  theme(
    text = element_text(family = "Times New Roman"),  # Set Times New Roman font for all text
    legend.position = "none",  # Remove legend
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank()  # Remove x-axis ticks
  )

# Total Counts
# Create a new column to classify points above/below the abline
das.dat@meta.data$above_abline_counts <- ifelse(das.dat@meta.data$nCount_RNA > 50000, "Above", "Below")
total.counts.plot <- ggplot(das.dat@meta.data,  
                            aes(x = samp.ident.desc, y = nCount_RNA, color = samp.ident.desc)) +
  geom_jitter(aes(shape = above_abline_counts)) +  # Change shape based on condition
  geom_violin() +
  geom_abline(intercept = 50000, slope = 0, color = "black", lty = 2) +
  labs(y = "Counts", x = NULL, title = NULL) +
  scale_shape_manual(values = c("Above" = 4, "Below" = 16)) +  # Crosses for above, circles for below
  theme_minimal() + 
  theme(
    text = element_text(family = "Times New Roman"),  # Set Times New Roman font for all text
    legend.position = "none",  # Remove legend
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank()  # Remove x-axis ticks
  )

# Unique Features
# Create a new column to classify points above/below the abline
das.dat@meta.data$below_abline_features <- ifelse(das.dat@meta.data$nFeature_RNA < 200, "Below", "Above")
unique.features.plot <- ggplot(das.dat@meta.data,  
                               aes(x = samp.ident.desc, y = nFeature_RNA, color = samp.ident.desc)) +
  geom_jitter(aes(shape = below_abline_features)) +  # Change shape based on condition
  geom_violin() +
  geom_abline(intercept = 200, slope = 0, color = "black", lty = 2) +
  labs(y = "Features", x = "Samples", title = NULL) +
  scale_shape_manual(values = c("Below" = 4, "Above" = 16)) +  # Crosses for below, circles for above
  theme_minimal() + 
  theme(
    text = element_text(family = "Times New Roman"),  # Set Times New Roman font for all text
    legend.position = "none",  # Remove legend
  )

# Plot counts against percent mt, looking for a good cutoff
plot.counts.vs.percent.mt <- FeatureScatter(das.dat, feature1 = "nCount_RNA", feature2 = "percent.mt")#, group.by = "high.percent.mt")
plot.counts.vs.percent.mt

# Create a combined plot for your methods chapter.
# Define labels with bold Times New Roman font
label_theme <- theme(
  plot.tag = element_text(family = "Times New Roman", face = "bold", size = 12)
)

# Assign labels to each plot
percent.mt.plot <- percent.mt.plot + label_theme + labs(tag = "A")
total.counts.plot <- total.counts.plot + label_theme + labs(tag = "B")
unique.features.plot <- unique.features.plot + label_theme + labs(tag = "C")

# Combine plots in one column and add a shared title
QC.plot <- (percent.mt.plot / total.counts.plot / unique.features.plot) +
  plot_layout(ncol = 1) +
  plot_annotation(
    title = "Quality Control Thresholds",
    theme = theme(
      plot.title = element_text(family = "Times New Roman", face = "bold", size = 12, hjust = 0.5)
    )
  )

# Save the image
ggsave(
  filename = "2_output/QC_plot.png",
  plot = QC.plot,
  width = 204.92, height = 250, units = "mm", dpi = 600
)
```

# Actually filter the data
```{r, warning=FALSE}
das.dat <- subset(das.dat, subset = nFeature_RNA > 200 & nCount_RNA < 50000 & percent.mt < 10)
```

# Normalisation
```{r}
# Using default settings
das.dat <- NormalizeData(das.dat, normalization.method = "LogNormalize", scale.factor = 10000)
```

# Feature selection
```{r}
# Using default settings to find the most variable features to inform our clustering
das.dat <- FindVariableFeatures(das.dat, selection.method = "vst", nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(das.dat), 10)

# # Plot all genes by variance, labeling the top 10
variable.genes <- VariableFeaturePlot(das.dat)
plot.variable.genes.lab <- LabelPoints(plot = variable.genes, points = top10, repel = TRUE)
plot.variable.genes.lab
```

# Dimensional reduction
```{r}
# Apply linear transformation prior to PCA and other downstream analyses
all.genes <- rownames(das.dat)
das.dat <- ScaleData(das.dat, features = all.genes)

# Perform linear dimensional reduction
das.dat <- RunPCA(das.dat, features = VariableFeatures(object = das.dat))

# Perform dimensional reduction with TSNE
# das.dat <- RunTSNE(das.dat, features = VariableFeatures(object = das.dat))

# Examine and visualize PCA results a few different ways
# Provide lists of positively and negatively regulated genes per PC
print(das.dat[["pca"]], dims = 1:5, nfeatures = 5)
# Shows clearly up and down regulated genes in PCs
VizDimLoadings(das.dat, dims = 1:2, reduction = "pca")
# Plots first two PCs and shows all genes in each sample
DimPlot(das.dat, reduction = "pca", shuffle = T)
# Can be used to inform which PCs to use for downstream analysis (but to do so you should plot all PCs)
DimHeatmap(das.dat, dims = 1, cells = 500, balanced = TRUE)
```

# Determine dimensionality of the data
```{r}
# This can help inform the number of PCs to use by plotting the distribution of p-values for each PC with a uniform distribution
# This bit can take awhile
das.dat <- JackStraw(das.dat, num.replicate = 100)
das.dat <- ScoreJackStraw(das.dat, dims = 1:20)

# The JackStrawPlot() function provides a visualization tool for comparing the distribution of p-values for each PC with a uniform distribution (dashed line). ‘Significant’ PCs will show a strong enrichment of features with low p-values (solid curve above the dashed line).
JackStrawPlot(das.dat, dims = 1:20)
# Alternatively, PCs can be ranked in a less computationally-intensive way using the ElbowPlot function
ElbowPlot(das.dat, ndims = 50)
# Looking at the ElbowPlot, since the JackStrawPlot is confusing, looks like about 12 PCs is pretty good
# More notes on these methods can be found in the Seurat guide
```

# Cluster the cells and visualise dimensions with UMAP
```{r}
# Construct a K nearest neighbours graph based on the distance between points in PCA space and refine edge weights between cells with Jaccard similarity. Using the first 11 PCs here.
das.dat <- FindNeighbors(das.dat, dims = 1:20)

# Cluster the cells using Louvain algorithm. Setting resolution between 0.4 and 1.2 for a 3K cells dataset is recommended in the documentation, but optimal resolution often increases for larger datasets. Started with a resolution of 0.6
das.dat <- FindClusters(das.dat, resolution = seq(0.1,1,length=10))

# Explore the effect of clustering resolution with clustree
clustree(das.dat)

png(filename = "2_output/clustree.png", width = 2000, height = 1000, units = "px", res = 150)
clustree(das.dat, show_axis = T) + NoLegend() + ylab("Seurat clustering resolution")
dev.off()
```

# Based on the output of clustree, identify an appropriate resolution to cluster at and run a UMAP
```{r}
# Define which resolution we want to use to define our "seurat_clusters" and idents, which are used in the following code
das.dat@meta.data[["seurat_clusters"]] <- das.dat@meta.data[["RNA_snn_res.0.6"]]
Idents(das.dat) <- das.dat@meta.data[["RNA_snn_res.0.6"]]

# Look at cluster IDs of the first 5 cells
head(Idents(das.dat), 5)

# Run and plot UMAP for dimensional reduction, first for all cells, second by treatment and third by sample names to show that the cells are clustered more by type than sample, and finally split by sample names to show the distribution of different clusters across each sample
das.dat <- RunUMAP(das.dat, dims = 1:20)
DimPlot(das.dat, reduction = "umap", label = T)
DimPlot(das.dat, reduction = "umap", split.by = "treat.ident", label = T)
DimPlot(das.dat, reduction = "umap", group.by = "samp.ident.plain")
DimPlot(das.dat, reduction = "umap", group.by = "treat.ident", label =T)
DimPlot(das.dat, reduction = "umap", split.by = "samp.ident.plain", label = T)
```

# Identify doublets now that the data is fully processed
-   There is an argument for doing this after you've annotated your clusters, because then you can remove ones with low UMIs or uninformative marker genes and it will work better.
-   DoubletFinder estimates artificial doublets and uses these to find real doublets.
-   The artificial doublets should represent potential real doublets, so the code should only be run on a group of samples that came from the same 10X run.
-   <https://github.com/chris-mcginnis-ucsf/DoubletFinder>
-   <https://github.com/EDePasquale/DoubletDecon>
-   DoubletDecon appears to work much earlier in the process, on Seurat files.
-   <https://github.com/plger/scDblFinder>
-   scDblFinder works on SingleCellExperiment objects. Notes this for doublet proportion:
-   The expected proportion of doublets has little impact on the score, but a very strong impact on where the threshold will be placed (the thresholding procedure simultaneously minimizes classification error and departure from the expected doublet rate). It is specified through the dbr parameter and the dbr.sd parameter (the latter specifies the standard deviation of dbr, i.e. the uncertainty in the expected doublet rate). For 10x data, the more cells you capture the higher the chance of creating a doublet, and Chromium documentation indicates a doublet rate of roughly 1% per 1000 cells captures (so with 5000 cells, (0.01*5)*5000 = 250 doublets), and the default expected doublet rate will be set to this value (with a default standard deviation of 0.015). Note however that different protocols may create considerably more doublets, and that this should be updated accordingly. If you are unsure about the doublet rate, set dbr.sd=1 and the thresholding will be entirely based on the misclassification rates.
```{r}
# Find an optimal pK value using other DoubletFinder functions
sweep.res.das.dat <- paramSweep_v3(das.dat, PCs = 1:20, sct = FALSE)
sweep.stats.das.dat <- summarizeSweep(sweep.res.das.dat, GT = FALSE)
pK.das.dat <- find.pK(sweep.stats.das.dat)
# Define optimal pK value
opt.pK <- pK.das.dat$pK[which.max(pK.das.dat$BCmetric)]
opt.pK <- as.numeric(levels(opt.pK))[opt.pK]

# Estimate proportion of homotypic doublets
homotypic.prop <- modelHomotypic(das.dat@meta.data$seurat_clusters)
nExp_poi <- round(0.075*nrow(das.dat@meta.data))  ## Assuming 7.5% doublet formation rate - tailor for your dataset
# To add varying confidence to classifications
nExp_poi.adj <- round(nExp_poi*(1-homotypic.prop))

# Define pN - doesn't affect the analysis very much
opt.pN <- 0.25

# Define name of doublet classification metadata object for plotting
# Regular
doubletFinder.groups <- paste0("DF.classifications_", opt.pN, "_", opt.pK, "_", nExp_poi)
# Adjusted
doubletFinder.groups.adj <- paste0("DF.classifications_", opt.pN, "_", opt.pK, "_", nExp_poi.adj)

# Run DoubletFinder
das.dat <- doubletFinder_v3(seu = das.dat, PCs = 1:20, pN = opt.pN, pK = opt.pK, nExp = nExp_poi, reuse.pANN = F, sct = F)

# Plot potential doublets and singlets
DimPlot(das.dat, reduction = "umap", group.by = doubletFinder.groups)

# Add a second level of confidence to classifications
das.dat <- doubletFinder_v3(seu = das.dat, PCs = 1:20, pN = 0.25, pK = opt.pK, nExp = nExp_poi.adj, reuse.pANN = paste0("pANN_", opt.pN, "_", opt.pK, "_", nExp_poi))

# Plot potential doublets and singlets
DimPlot(das.dat, reduction = "umap", group.by = doubletFinder.groups.adj)

# Plot counts across samples to see if certain samples have more doublets, or if doublets have high counts
ggplot(das.dat@meta.data,  
       aes(x = samp.ident.desc, y =nCount_RNA, color = doubletFinder.groups.adj)) +
  geom_jitter() +
  # geom_violin() +
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y = "Counts", x = "Samples", title = "Counts")

#
plot.counts.vs.percent.mt <- FeatureScatter(das.dat, feature1 = "nCount_RNA", feature2 = "percent.mt", group.by = doubletFinder.groups.adj)
plot.counts.vs.percent.mt

table(das.dat@meta.data[[doubletFinder.groups.adj]])
table(das.dat@meta.data[[doubletFinder.groups.adj]]) %>% prop.table()
# With unfiltered cells 237 doublets (7.48%) and 2928 singlets (92.5%)
# With filtered cells and the second round of doublet classification, 210 doublets (7%) and 2771 singlets (93%)
# The only thing that really remains to be done here is see if there's some way to figure out if your expected proportion of doublets is 7.5% or not, because that's the major assumption of this algorithm currently.
```

# Filter out doublets
```{r}
das.dat <- subset(das.dat, subset = DF.classifications_0.25_0.005_205 == "Singlet")
```

# Attempt to assign some cell types automatically using sc-type and its database
# Create database of reference data and gene sets for sc-type
```{r}
# Load database
database <- "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx";
# Define tissue type
tissue <- "Stomach"
# Guess tissue type
# tissue_guess = auto_detect_tissue_type(path_to_db_file = database, seuratObject = das.dat, scaled = FALSE, assay = "RNA")
# if scaled = TRUE, make sure the data is scaled, as seuratObject[[assay]]@scale.data is used. If you just created a Seurat object, without any scaling and normalization, set scaled = FALSE, seuratObject[[assay]]@counts will be used         
# Prepare gene sets
gs_list <- gene_sets_prepare(database, tissue)
```

# Find Marker Genes for each cluster with Seurat and sctype
```{r}
# Find markers with Seurat
das.markers <- FindAllMarkers(das.dat, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25) %>% .[order(.$avg_log2FC, decreasing = TRUE ),]
# das.markers <- FindAllMarkers(das.dat, only.pos = TRUE) #, min.pct = 0.25) #, logfc.threshold = 0.25)

# Assign cell types to each cluster using sctype
es.max = sctype_score(scRNAseqData = das.dat[["RNA"]]@scale.data, scaled = TRUE, 
                      gs = gs_list$gs_positive, gs2 = gs_list$gs_negative) 

# Merge by cluster
cl_results = do.call("rbind", lapply(unique(das.dat@meta.data$seurat_clusters), function(cl){
  es.max.cl = sort(rowSums(es.max[ ,rownames(das.dat@meta.data[das.dat@meta.data$seurat_clusters==cl, ])]), decreasing = !0)
  head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(das.dat@meta.data$seurat_clusters==cl)), 10)
}))
sctype_scores = cl_results %>% group_by(cluster) %>% top_n(n = 1, wt = scores)  

# set low-confident (low ScType score) clusters to "unknown"
sctype_scores$type[as.numeric(as.character(sctype_scores$scores)) < sctype_scores$ncells/4] = "Unknown"
print(sctype_scores[,1:3])
#sctype_score uses positive (gs) and negative (gs2) markers. If you don't want to use negative markers, set gs2 to NULL

# Assign types and plot UMAP
das.dat@meta.data$type.sctype = ""
for(j in unique(sctype_scores$cluster)){
  cl_type = sctype_scores[sctype_scores$cluster==j,]; 
  das.dat@meta.data$type.sctype[das.dat@meta.data$seurat_clusters == j] = as.character(cl_type$type[1])
}

# Bubble plot
# prepare edges
cl_results=cl_results[order(cl_results$cluster),]; edges = cl_results; edges$type = paste0(edges$type,"_",edges$cluster); edges$cluster = paste0("cluster ", edges$cluster); edges = edges[,c("cluster", "type")]; colnames(edges) = c("from", "to"); rownames(edges) <- NULL

# prepare nodes
nodes_lvl1 = sctype_scores[,c("cluster", "ncells")]; nodes_lvl1$cluster = paste0("cluster ", nodes_lvl1$cluster); nodes_lvl1$Colour = "#f1f1ef"; nodes_lvl1$ord = 1; nodes_lvl1$realname = nodes_lvl1$cluster; nodes_lvl1 = as.data.frame(nodes_lvl1);
nodes_lvl2 = c(); 
ccolss= c("#5f75ae","#92bbb8","#64a841","#e5486e","#de8e06","#eccf5a","#b5aa0f","#e4b680","#7ba39d","#b15928","#ffff99", "#6a3d9a","#cab2d6","#ff7f00","#fdbf6f","#e31a1c","#fb9a99","#33a02c","#b2df8a","#1f78b4","#a6cee3", "#03dbfc")
for (i in 1:length(unique(cl_results$cluster))){
  dt_tmp = cl_results[cl_results$cluster == unique(cl_results$cluster)[i], ]; nodes_lvl2 = rbind(nodes_lvl2, data.frame(cluster = paste0(dt_tmp$type,"_",dt_tmp$cluster), ncells = dt_tmp$scores, Colour = ccolss[i], ord = 2, realname = dt_tmp$type))
}

nodes = rbind(nodes_lvl1, nodes_lvl2); nodes$ncells[nodes$ncells<1] = 1;
files_db = openxlsx::read.xlsx(database)[,c("cellName","shortName")]; files_db = unique(files_db); nodes = merge(nodes, files_db, all.x = T, all.y = F, by.x = "realname", by.y = "cellName", sort = F)
nodes$shortName[is.na(nodes$shortName)] = nodes$realname[is.na(nodes$shortName)]; nodes = nodes[,c("cluster", "ncells", "Colour", "ord", "shortName", "realname")]

# Remove inexplicably duplicated rows, where shortname is mesothelial, not mesothelial_cells
nodes <- nodes[nodes$shortName != "Mesothelial", ]

mygraph <- graph_from_data_frame(edges, vertices=nodes)
# Doesn't work due to duplicate vertex names (first column of nodes). This is because for some reason each of the mesothelial cell clusters is duplicated, with one including the short name "mesothelial", and the other "mesothelial_cells"

# Make the graph
plot.sctype.per.cluster <- ggraph(mygraph, layout = 'circlepack', weight=I(ncells)) + 
  geom_node_circle(aes(filter=ord==1,fill=I("#F5F5F5"), colour=I("#D3D3D3")), alpha=0.9) + geom_node_circle(aes(filter=ord==2,fill=I(Colour), colour=I("#D3D3D3")), alpha=0.9) +
  theme_void() + geom_node_text(aes(filter=ord==2, label=realname, colour=I("#ffffff"), fill="white", repel = !1, parse = T, size = I(log(ncells,25)*1.2)))+ geom_node_label(aes(filter=ord==1,  label=realname, colour=I("#000000"), size = I(3), fill="white", parse = T), repel = !0, segment.linetype="dotted")

# Use gridExtra to print these graphs next to each other, with the UMAP annotated with original cluster ID's, not annotated cell types
png(filename = "2_output/type.sctype_and_types_per_cluster.png", width = 2000, height = 1000, units = "px")
gridExtra::grid.arrange(DimPlot(das.dat, reduction = "umap", label = TRUE, repel = TRUE, cols = ccolss, group.by = "type.sctype"), plot.sctype.per.cluster, ncol = 2)
dev.off()

# UMAP with sctype types and treatment identification
png(filename = "2_output/type.sctype_by_treat.ident.png", width = 1500, height = 1000, units = "px")
DimPlot(das.dat, reduction = "umap", split.by = "treat.ident", group.by = "type.sctype", label = T)
dev.off()
DimPlot(das.dat, reduction = "umap", split.by = "treat.ident", group.by = "type.sctype", label = T)

# UMAP with seurat cluster idents
png(filename = "2_output/seurat_cluster.png", width = 1500, height = 1000, units = "px")
DimPlot(das.dat, reduction = "umap", label = TRUE, repel = TRUE)
dev.off()
DimPlot(das.dat, reduction = "umap", label = TRUE, repel = TRUE)

# UMAP with seurat cluster idents and treatment identification
png(filename = "2_output/seurat_cluster_by_treat.ident.png", width = 1500, height = 1000, units = "px")
DimPlot(das.dat, reduction = "umap", label = TRUE, repel = TRUE, split.by = "treat.ident")
dev.off()

# sctype annotations per cluster
plot.sctype.per.cluster

# Dumb investigative plots
FeaturePlot(das.dat, features = c("Epcam"))
FeaturePlot(das.dat, features = c("Cdh1"))
FeaturePlot(das.dat, features = c("Krt7"))
FeaturePlot(das.dat, features = c("Cldn4"))
VlnPlot(das.dat, features = c("Cdh1", "Epcam"))

FeatureScatter(das.dat, "Cdh1", "Epcam", cells = which(das.dat@meta.data[["seurat_clusters"]] == 4))
```

# Miscellaneous plotting of various genes, can probably mostly be removed
```{r}
# Do these all on Vlnplots, which mean you don't need to shape.by cluster and look way better
# Muc13 and Dmbt1, named markers for cluster 8
VlnPlot(das.dat, features = c("Muc13", "Dmbt1"),  group.by = "seurat_clusters")
# Dmbt1 isn't as strong of a marker for cluster 8, which is why it isn't on the list, but is expressed here
# Alpi and Akp3 (human/mouse orthologs), top 2 markers for cluster 8
VlnPlot(das.dat, features = c("Alpi", "Akp3"),  group.by = "seurat_clusters")
# Ada and Adh6a, top third and fourth markers for cluster 8
VlnPlot(das.dat, features = c("Ada", "Adh6a"),  group.by = "seurat_clusters")

# Let's also look at Cdh1 and Trp53 - If we're looking at cancer cells (but only the responding ones) in cluster 8, we'd hope these genes weren't expressed strongly there
# Cdh1
VlnPlot(das.dat, features = "Cdh1",  group.by = "seurat_clusters")
#Trp53
VlnPlot(das.dat, features = "Trp53",  group.by = "seurat_clusters")
# Epcam (epithelial cell marker)
VlnPlot(das.dat, features = "Epcam",  group.by = "seurat_clusters")
# Cd44 (since Cdh1/Trp53 KO cells should be expressing Cd44
VlnPlot(das.dat, features = "Cd44",  group.by = "seurat_clusters")
# Krt14, which is underexpressed with Cdh1 loss according to a paper from the lab
VlnPlot(das.dat, features = "Krt14",  group.by = "seurat_clusters") 
# Plot Olfm4, Cdh17, Krt20, Muc5ac, Lgals4, Akr1B10, and Reg4, all of which have been found decently expressed in human gastric cancer
VlnPlot(das.dat, features = c("Olfm4", "Cdh17", "Krt20", "Muc5ac"), group.by = "seurat_clusters")

VlnPlot(das.dat, features = c("Lgals4", "Akr1B10", "Reg4"), group.by = "type.sctype")

# ---------------------------------------------------------------------------------------------------------------

# Try to find other clusters that might represent cancer cells by plotting Cdh1 and Trp53 across all samples (Dmbt1 and Muc13 are just for fun, they probably aren't important in cancer as a whole), as this should be consistent
# VlnPlot
VlnPlot(das.dat, features = c("Cdh1", "Trp53", "Cd44", "Dmbt1", "Muc13"),  group.by = "seurat_clusters")
# Also plot Gkn2, Tff1, Tff2,normal gastric mucosal epithelial markers https://www.cell.com/cell-reports/pdfExtended/S2211-1247(22)01332-8
VlnPlot(das.dat, features = c("Cdh1", "Gkn2", "Tff1", "Tff2"), group.by = "seurat_clusters")
# Plot some good enterocyte markers (the top 5 on Panglao, plus Apobec1 for fun) to see if they're more highly expressed in cluster 8
VlnPlot(das.dat, features = c("Slc10a2", "Alpi", "Krt20", "Si", "Rnf186", "Klf5", "Apobec1"),  group.by = "seurat_clusters")
# Plot Msmb, a gene identified as a marker for signet ring cells in a paper file:///C:/Users/axonn/OneDrive/University/PhD/Papers%20etc/Single-cell%20analysis%20of%20gastric%20signet%20ring%20cell%20carcinoma.pdf
VlnPlot(das.dat, features = "Msmb", group.by = "type.sctype")
FeaturePlot(das.dat, features = "Msmb")

#FeaturePlot
FeaturePlot(das.dat, features = c("Cdh1", "Trp53", "Cd44", "Dmbt1", "Muc13"))
# Also plot Gkn2, Tff1, Tff2,normal gastric mucosal epithelial markers https://www.cell.com/cell-reports/pdfExtended/S2211-1247(22)01332-8
FeaturePlot(das.dat, features = c("Cdh1", "Gkn2", "Tff1", "Tff2"))
# Also plot  some markers of apoptosis to see if cluster 8 is apoptosing
# CD95 (Fas), CD40, CD49d (Itga4) and CD11a, plus some others
FeaturePlot(das.dat, features = c("Fas", "Cd40", "Itga4", "Itgal", "Fasl", "Bcl2", "Nfkb1"))
# None of these cluster obviously to cluster 8 (or anywhere really)

# Featureplot proliferation markers
FeaturePlot(das.dat, features = c("Trp53", "Cdh1", "Mki67"))


DimPlot(das.dat, reduction = "umap", label = TRUE, repel = TRUE)
DimPlot(das.dat, reduction = "umap", label = TRUE, repel = TRUE, group.by = 'type.sctype')
# Cells clustered as and "Myeloid cells" (cluster 1), "Lymphatic endothelial cells" (cluster 2), and "Mesothelial cells" (cluster 4) are also lacking in both Cdh1 and Trp53 (mainly Cdh1), So may also represent cancer (or just cells that don't normally express these genes, such as non-epithelial cells)
```

# Thesis UMAP - un-annotated for Chapter 3.3
```{r}
# Define new labels for the treatment groups
new_labels <- c("Das - control" = "Control",
                "Das - drug" = "Dasatinib") # Modify accordingly

# Generate UMAP plot
p <- DimPlot(das.dat, reduction = "umap", label = TRUE, repel = TRUE, split.by = "treat.ident", group.by = "seurat_clusters", pt.size = 0.2, label.size = 3) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(), # Remove gridlines
    axis.line = element_line(), # Keep axis lines
    axis.ticks = element_blank(), # Remove axis ticks
    axis.text = element_blank(), # Remove axis tick labels
    text = element_text(family = "Times New Roman", size = 12), # Set font for all text
    plot.title = element_text(face = "bold", size = 12, family = "Times New Roman"), # Title styling
    legend.key.size = unit(0.5, "lines"), # Make legend more compact
    legend.position = "bottom",
    legend.text = element_text(size = 12, family = "Times New Roman"), # Legend text size
    legend.title = element_text(size = 12, family = "Times New Roman", face = "bold"), # Bold legend title
    strip.text = element_text(family = "Times New Roman", size = 12, face = "bold") # Facet panel title styling
  ) +
  labs(title = "Seurat Clusters by Treatment") +
  facet_wrap(~treat.ident, labeller = as_labeller(new_labels)) # Rename panel titles

# Save the plot with A4 width minus margins
ggsave(file = "2_output/Seurat_Clusters_by_Treatment.png", plot = p, width = 15.92, height = 10, units = "cm", dpi = 600)
# Tidy up the environment
rm("new_labels")
```

# Thesis Heatmap for Chapter 3.3.3
```{r}
# Identify top markers for each cluster
das.markers %>%
  group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 1) %>%
  slice_head(n = 5) %>%
  ungroup() -> top5

# Create the heatmap
p <- DoHeatmap(das.dat, group.by = "seurat_clusters", features = top5$gene, size = 2, group.bar = TRUE) + 
  theme_void() +  # Remove grey background
  theme(
    axis.text.y = element_text(size = 7, family = "Times New Roman", face = "italic"), # Italicized gene labels (Y-axis)
    axis.text.x = element_blank(), # Remove X-axis labels
    axis.title = element_text(size = 12, family = "Times New Roman"), # Axis titles size 12
    plot.title = element_text(face = "bold", size = 12, family = "Times New Roman"), # Bold title
    text = element_text(family = "Times New Roman", size = 12), # Set default font to Times New Roman
    plot.background = element_rect(fill = "white", color = NA), # Ensures white background
    legend.position = "none" # Remove legend
  ) +
  plot_annotation(title = "Expression of Top Five Positive Marker Genes by Cluster", 
                  theme = theme(plot.title = element_text(face = "bold", size = 12, family = "Times New Roman")))
                  
# Save the heatmap with A4 width minus margins in high resolution
ggsave("2_output/Markers_Heatmap.png", plot = p, width = 15.92, height = 22, units = "cm", dpi = 600)
```

# Write a loop to pull out markers for individual clusters as separate objects
```{r}
# Create empty list
das.markers.list <- list()
# Fill list
for(i in levels(das.markers$cluster)){
  das.markers.list[[i]] <- das.markers %>% 
    group_by(cluster) %>% 
    filter(cluster == i)
  # Rename data.frame columns within list
  names(das.markers.list[[i]]) <- colnames(das.markers)
}

# Print the top 5 markers for each cluster
for(i in 1:length(das.markers.list)){
  das.markers.list[[i]] %>% head(., n = 5) %>% print(.)
}

# Put the top 5 markers from each cluster into a new data frame for easier viewing and annotation
das.markers.top5.list <- lapply(das.markers.list, function(df) head(df, 5))
# Use do.call to combine the list of data frames into a single data frame
das.markers.top5.data.frame <- do.call(rbind, das.markers.top5.list)

# Write out das.markers to link to in supplementary tables
write.csv(das.markers, file = "2_output/markers.csv", row.names = F)
```

# After a very thorough literature search of the top 5 positive marker genes (by log2 FC) for each cluster, re-label each cluster with your best guesses for identity
```{r}
# Streamlined classifications
type.manual.v1 <- c("Pit Cells", "Fibroblasts", "Macrophages", "Mesothelial Cells", "Proliferating Epithelial Cells", "T Cells", "Chief Cells", "Mucous Cells", "Smooth Muscle Cells", "Parietal Cells", "Enterocytes", "Mesothelial Cells", "B Cells", "Endothelial Cells", "Fibroblasts", "Undetermined", "Neutrophils", "Enteroendocrine Cells", "Proliferating Epithelial Cells")

# Add to a data frame so you know which Seurat clusters they relate to
seurat.cluster <- 0:18
# Create the data frame
type.to.cluster <- data.frame(
  type.manual.v1 = type.manual.v1,
  seurat.cluster = seurat.cluster
)

# Add as metadata to the object
names(type.manual.v1) <- levels(das.dat)
das.dat <- RenameIdents(das.dat, type.manual.v1)
das.dat@meta.data[["type.manual.v1"]] <- das.dat@active.ident

png("2_output/type.manual.v1_by_treat.ident.png", height = 2000, width = 2000, units = "px", pointsize = 20)
DimPlot(das.dat, reduction = "umap", label = TRUE, repel = TRUE, label.size = 10, label.box = F, pt.size = 2, group.by = "type.manual.v1", split.by = "treat.ident") + xlim(NA, 10) + NoLegend() + theme(
  axis.text.x = element_blank(), axis.ticks.x = element_blank(), 
  axis.text.y = element_blank(), axis.ticks.y = element_blank(),
  axis.title = element_blank(),
  strip.text.x = element_text(size = 40, face = "bold"))
dev.off()

png("2_output/type.manual.v1.png", height = 2000, width = 2000, units = "px", pointsize = 20)
DimPlot(das.dat, reduction = "umap", label = TRUE, repel = TRUE, label.size = 10, pt.size = 2, group.by = "type.manual.v1") + xlim(NA, 10) + NoLegend() + theme(
  axis.text.x = element_blank(), axis.ticks.x = element_blank(), 
  axis.text.y = element_blank(), axis.ticks.y = element_blank(),
  axis.title = element_blank(),
  strip.text.x = element_text(size = 40, face = "bold"))
dev.off()

png("2_output/VlnPlotCdh1.png", height = 1000, width = 2000, units = "px", res = 0.4, pointsize = 300)
VlnPlot(das.dat, features = "Cdh1", pt.size = 1) + NoLegend() +theme(axis.text.x=element_text(size=30))
dev.off()

VlnPlot(das.dat, features = "Cdh1") + NoLegend()

png("2_output/type.manual.v1_by_samp.ident.desc.png", height = 1000, width = 2000, units = "px", pointsize = 20)
DimPlot(das.dat, reduction = "umap", label = TRUE, pt.size = 0.8, group.by = "type.manual.v1", split.by = "samp.ident.desc") + xlim(NA, 10) + NoLegend()
dev.off()

png("2_output/type.sctype_by_treat.ident.png", height = 2000, width = 2000, units = "px", pointsize = 20)
DimPlot(das.dat, reduction = "umap", label = TRUE, repel = TRUE, pt.size = 2, group.by = "type.sctype", split.by = "treat.ident", label.size = 10) + xlim(NA, 10) + NoLegend() + theme(
  axis.text.x = element_blank(), axis.ticks.x = element_blank(), 
  axis.text.y = element_blank(), axis.ticks.y = element_blank(),
  axis.title = element_blank(),
  strip.text.x = element_text(size = 40, face = "bold"))
dev.off()

# UMAP with seurat cluster idents
png(filename = "2_output/seurat_cluster.png", width = 2000, height = 1000, units = "px", pointsize = 20)
DimPlot(das.dat, group.by = "seurat_clusters", reduction = "umap", label = F, pt.size = 2, repel = TRUE, label.size = 15) + xlim(NA, 10) + NoLegend() + theme(
  axis.text.x = element_blank(), 
  axis.ticks.x = element_blank(), 
  axis.text.y = element_blank(), 
  axis.ticks.y = element_blank(),
  axis.title = element_blank())
dev.off()
DimPlot(das.dat, reduction = "umap", label = TRUE, repel = TRUE)
```

# How many cells in each cluster?
```{r}
table(das.dat@meta.data$type.manual.v1)
```

# Thesis UMAP - annotated for Chapter 3.3.3
```{r}
# Define new labels for the treatment groups
new_labels <- c("Das - control" = "Control",
                "Das - drug" = "Dasatinib") # Modify accordingly

# Generate UMAP plot
p <- DimPlot(das.dat, reduction = "umap", label = TRUE, repel = TRUE, group.by = "type.manual.v1", split.by = "treat.ident", pt.size = 0.1, label.size = 2.4) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(), # Remove gridlines
    axis.line = element_line(), # Keep axis lines
    axis.ticks = element_blank(), # Remove axis ticks
    axis.text = element_blank(), # Remove axis tick labels
    text = element_text(family = "Times New Roman", size = 12), # Set font for all text
    plot.title = element_text(face = "bold", size = 12, family = "Times New Roman"), # Title styling
    legend.position = "bottom", # Move legend below the plot
    legend.key.size = unit(0.5, "lines"), # Make legend more compact
    legend.text = element_text(size = 9, family = "Times New Roman"), # Legend text size
    legend.title = element_text(size = 9, family = "Times New Roman", face = "bold"), # Bold legend title
    strip.text = element_text(family = "Times New Roman", size = 12, face = "bold") # Facet panel title styling
  ) +
  labs(title = "Annotated Clusters by Treatment") +
  facet_wrap(~treat.ident, labeller = as_labeller(new_labels)) # Rename panel titles

# Save the plot with A4 width minus margins
ggsave(file = "2_output/Annotated_Clusters_by_Treatment.png", plot = p, width = 15.92, height = 10, units = "cm", dpi = 600)

# Tidy up the environment
rm("new_labels")
```


# Export the Seurat object at this stage to use it in other workflows
```{r}
saveRDS(das.dat, file = "2_output/das_dat_processed.RDS")
```
