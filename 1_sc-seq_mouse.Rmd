---
title: "1_sc-seq_mouse"
author: "Kieran Redpath"
date: "2023-09-10"
output: html_document
---

# Can also try everything with SingleR (probably better) or CHETAH for cell type annotation and also machine learning thingy

# Setup
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load packages
```{r, warning=FALSE}
# Load packages
library(dplyr)
library(Seurat)
library(patchwork)
library(celldex)
library(SingleR)
library(scater)
# Set seed
set.seed(42)
```

# Load data
```{r}
# Load annotated cellranger output for all samples
mouse.dat <- readRDS("~/R/sc-seq_mouse/data/scDrugMiceAll_annotated.RDS")
```

# Quality control
```{r, warning=FALSE}
# Examine proportion of mitochondrial features, as well as n features and counts per sample.
mouse.dat[["percent.mt"]] <- PercentageFeatureSet(mouse.dat, pattern = "^mt-")
VlnPlot(mouse.dat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
# there are varying proportions of mt genes across samples

# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot.counts.vs.features <- FeatureScatter(mouse.dat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot.counts.vs.features

# Look for outliers to remove that are at least 3 MADS (mean absolute deviations) from the mean
high.percent.mt <- isOutlier(mouse.dat@meta.data[["percent.mt"]], nmads = 3, type = "higher")
table(high.percent.mt)
attr(high.percent.mt, "thresholds")[2]
# This would exclude xxx cells based on mtDNA percentage
low.high.features <- isOutlier(mouse.dat@meta.data[["nFeature_RNA"]], nmads = 3, type = "both")
table(low.high.features)
attr(low.high.features, "thresholds")
# This would exclude xxx cells based on nFeatures
low.high.counts <- isOutlier(mouse.dat@meta.data[["nCount_RNA"]], nmads = 3, type = "both")
table(low.high.counts)
attr(low.high.counts, "thresholds")
# This would exclude xxx cells based on nCounts

# On the following plot, many of the cells with very high proportions of mtDNA have very few features, indicating that they aren't good quality
plot.features.vs.percent.mt <- FeatureScatter(mouse.dat, feature1 = "nFeature_RNA", feature2 = "percent.mt")
plot.features.vs.percent.mt

# Try and plot some of these thresholds on the data to see what you're removing:
# Add high percent mt information to metadata
mouse.dat@meta.data[["high.percent.mt"]] <- high.percent.mt
# Plot percent mt against total counts
ggplot(mouse.dat@meta.data,  
       aes(x = nCount_RNA, y = percent.mt, color = high.percent.mt)) +
  geom_point() +
  labs(y = "Percentage mitochondrial transcripts", x = "Counts", title = "Mitochondrial transcripts")

# Plot percent mt across samples to see if any are especially high
ggplot(mouse.dat@meta.data,  
       aes(x = samp.ident.desc, y = percent.mt, color = samp.ident.desc)) +
  geom_jitter() +
  geom_violin() +
  geom_abline(intercept = attr(high.percent.mt, "thresholds")[2], slope = 0, color = "black") +
  geom_abline(intercept = 10, slope = 0, color = "black", lty = 2) +
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y = "% Mitochondrial counts", x = "Samples", title = "% Mitochondrial counts")

# Plot counts against samples to see which samples have more counts
ggplot(mouse.dat@meta.data,  
       aes(x = samp.ident.desc, y =nCount_RNA, color = samp.ident.desc)) +
  geom_jitter() +
  geom_violin() +
  geom_abline(intercept = attr(low.high.counts, "thresholds")[1], slope = 0, color = "black") +
  geom_abline(intercept = attr(low.high.counts, "thresholds")[2], slope = 0, color = "black") +
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y = "Counts", x = "Samples", title = "Counts")

# Plot features against samples to see which samples have more features
ggplot(mouse.dat@meta.data,  
       aes(x = samp.ident.desc, y =nFeature_RNA, color = samp.ident.desc)) +
  geom_jitter() +
  geom_violin() +
  geom_abline(intercept = attr(low.high.features, "thresholds")[1], slope = 0, color = "black") +
  geom_abline(intercept = attr(low.high.features, "thresholds")[2], slope = 0, color = "black") +
  geom_abline(intercept = 200, slope = 0, color = "black", lty = 2) +
  geom_abline(intercept = 7500, slope = 0, color = "black", lty = 2) +
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y = "Features", x = "Samples", title = "Features")

# Plot counts against percent mt, looking for a good cutoff
plot.counts.vs.percent.mt <- FeatureScatter(mouse.dat, feature1 = "nCount_RNA", feature2 = "percent.mt") #, fill.by = "high.percent.mt")
plot.counts.vs.percent.mt
```

# Filter data with thresholds based on the above plots
```{r}
# This line is adapted from the Seurat tutorial with the goal of filtering out doublets (at least by filtering on counts), however our data uses probes to try and capture more features with the same amount of reads so may need to be treated differently. This is very light filtering.
# mouse.dat <- subset(mouse.dat, subset = nFeature_RNA > 200)
```

# Normalisation
```{r}
# Using default settings
mouse.dat <- NormalizeData(mouse.dat, normalization.method = "LogNormalize", scale.factor = 10000)
```

# Feature selection
```{r}
# Using default settings to find the most variable features to inform our clustering
mouse.dat <- FindVariableFeatures(mouse.dat, selection.method = "vst", nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(mouse.dat), 10)

# # Plot all genes by variance, labelling the top 10
plot.variable.genes <- VariableFeaturePlot(mouse.dat)
plot.variable.genes.lab <- LabelPoints(plot = plot.variable.genes, points = top10, repel = TRUE)
plot.variable.genes.lab
```

# Dimensional reduction
```{r}
# Apply linear transformation prior to PCA and other downstream analyses
all.genes <- rownames(mouse.dat)
mouse.dat <- ScaleData(mouse.dat, features = all.genes)

# Perform linear dimensional reduction
mouse.dat <- RunPCA(mouse.dat, features = VariableFeatures(object = mouse.dat))

# Examine and visualize PCA results a few different ways
# Provide lists of positively and negatively regulated genes per PC
print(mouse.dat[["pca"]], dims = 1:5, nfeatures = 5)
# Shows clearly up and down regulated genes in PCs
VizDimLoadings(mouse.dat, dims = 1:2, reduction = "pca")
# Plots first two PCs and shows all genes in each sample
DimPlot(mouse.dat, reduction = "pca")
# Can be used to inform which PCs to use for downstream analysis (but to do so you should plot all PCs)
DimHeatmap(mouse.dat, dims = 1, cells = 500, balanced = TRUE)
```

# prcomp on data: percent variation explained by each pc, instead of elbowplot
# Determine dimensionality of the data, and decide how many pc's to use for the rest of your analysis
```{r}
# This can help inform the number of PCs to use by plotting the distribution of p-values for each PC with a uniform distribution
# This bit can take awhile
mouse.dat <- JackStraw(mouse.dat, num.replicate = 100)
mouse.dat <- ScoreJackStraw(mouse.dat, dims = 1:20)

# The JackStrawPlot() function provides a visualization tool for comparing the distribution of p-values for each PC with a uniform distribution (dashed line). ‘Significant’ PCs will show a strong enrichment of features with low p-values (solid curve above the dashed line).
JackStrawPlot(mouse.dat, dims = 1:20)
# Alternatively, PCs can be ranked in a less computationally-intensive way using the ElbowPlot function
ElbowPlot(mouse.dat, ndims = 50)
# Looking at the ElbowPlot, since the JackStrawPlot is confusing, looks like about 16 PCs is pretty good, although Mik suggest picking much more or slightly less would also make sense, trying to find the point on the elbow plot where it begins to flatten.
# More notes on these methods can be found in the Seurat guide
```

# Cluster the cells and visualise dimensions with UMAP or tSNE
```{r}
# Construct a K nearest neighbours graph based on the distance between points in PCA space and refine edge weights between cells with Jaccard similarity. Using the first 16 PCs here.
mouse.dat <- FindNeighbors(mouse.dat, dims = 1:17)

# Cluster the cells using Louvain algorithm. Setting resolution between 0.4 and 1.2 for a 3K cells dataset is recommended in the documentation, but optimal resolution often increases for larger datasets.
mouse.dat <- FindClusters(mouse.dat, resolution = 0.6)

# Look at cluster IDs of the first 5 cells
head(Idents(mouse.dat), 5)

# Run and plot UMAP for dimensional reduction, first for all cells, second by treatment and third by sample names to show that the cells are clustered more by type than sample
mouse.dat <- RunUMAP(mouse.dat, dims = 1:17)
DimPlot(mouse.dat, reduction = "umap", label = T)
DimPlot(mouse.dat, reduction = "umap", split.by = "treat.ident", label = T)
DimPlot(mouse.dat, reduction = "umap", group.by = "samp.ident")
```

# Find cluster biomarkers
```{r}
# # Find differentially expressed features to use as cluster biomarkers
# Is it purely looking for genes specific to a cluster? Yes, genes are highly expressed in a cluster, and not in any other (so it's not necessarily the top expressed genes in that cluster)
# Find markers for all clusters (compared to all other cells), and report the positive ones
mouse.markers <- FindAllMarkers(mouse.dat, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
mouse.markers %>%
    group_by(cluster) %>%
    slice_max(n = 2, order_by = avg_log2FC)
```

# Plot some interesting genes - suppressing most of these plots for now as they aren't essential
```{r}
# # Normalised genes across clusters
# VlnPlot(mouse.dat, features = c("Cdh1", "Trp53"))
# 
# # Multiple drug-related genes across the whole dataset
# FeaturePlot(mouse.dat, features = c("Cdh1", "Trp53", "Erbb2", "Src", "Ddr2", "Akt3"))
# # Cdh1 by treatment
# FeaturePlot(mouse.dat, split.by = "treat.ident", features = "Cdh1")
# 
# # Expression heatmap for top 5 features in each cluster (can't get this to work)
# mouse.markers %>%
#     group_by(cluster) %>%
#     top_n(n = 5, wt = avg_log2FC) -> top5
# # For some reason this heatmap just does not work
# # png(file ="1_output/Heatmap.png", width = 4000, height = 4000)
# # DoHeatmap(mouse.dat, features = top5$gene) + NoLegend()
# # dev.off()
# 
# FeaturePlot(mouse.dat, features = c("Cdh1", "Trp53"))
# FeaturePlot(mouse.dat, features = c("Epcam", "Ctnna1"))
```

# Load and manipulate data for cell type annotation with SingleR and celldex
```{r}
# Load mouse reference RNAseq data
mouse_ref <- celldex::MouseRNAseqData()
# Create SingleCellExperiment version of mouse.dat at the point it currently stands. This strips metadata, but will retain normalisation
mouse_sce <- as.SingleCellExperiment(mouse.dat)
```

# Annotate dataset with SingleR and celldex
```{r}
# Use broader cell types
type.SingleR.main <- SingleR(mouse_sce, assay.type.test = 1, ref = mouse_ref, labels = mouse_ref$label.main)
# Use more granular cell type definitions (probably more useful)
type.SingleR.fine <- SingleR(mouse_sce, assay.type.test = 1, ref = mouse_ref, labels = mouse_ref$label.fine)
```

# Exploration of cell type annotations
```{r}
# Broad annotations, pruned cell types (based on confidence of call) vs raw
table(type.SingleR.main$pruned.labels)
table(type.SingleR.main$labels)

# Fine annotations, pruned cell types (based on confidence of call) vs raw
table(type.SingleR.fine$pruned.labels)
table(type.SingleR.fine$labels)

# Doesn't look like there's any differences in the pruned labels in this case.
```

# Add these labels to the original object
```{r}
# Broad annotations
mouse.dat@meta.data[["type.SingleR.main"]] <- type.SingleR.main$labels %>% as.factor()
 # Fine annotations
mouse.dat@meta.data[["type.SingleR.fine"]] <- type.SingleR.fine$labels %>% as.factor()
# Plot these - NOTE: YOU ACTUALLY NEED TO DO THE REDUCTION FIRST!
DimPlot(mouse.dat, reduction = "umap",
split.by = "treat.ident", label = F, group.by = "type.SingleR.main")
# Plot these
DimPlot(mouse.dat, reduction = "umap",
split.by = "treat.ident", label = F, group.by = "type.SingleR.fine")
```

# Compare SingleR cell type proportions with metadata values
```{r}
# Cell type vs treatment group (prop)
table(mouse.dat@meta.data[["type.SingleR.main"]], mouse.dat@meta.data[["treat.ident"]]) %>%
prop.table(., 2) %>% round(.,2)

# Cell type vs mouse (prop)
table(mouse.dat@meta.data[["type.SingleR.main"]], mouse.dat@meta.data[["samp.ident.desc"]]) %>%
prop.table(., 2) %>% round(.,2)
```

# Attempt to assign some cell types automatically using sc-type and its database
```{r}
# Load required packages (only for converting gene symbols that have been re-formatted by R, but need to be loaded as functions are used by gene_sets_prepare)
library(HGNChelper)
library(openxlsx)
# Load sc-type R functions
# To prepare gene sets
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R");
# To score cell type annotation confidence
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")
# To auto-detect tissue type
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/auto_detect_tissue_type.R")
```

# Start analysing data correctly
```{r}
# Load database
database <- "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx";
# Define tissue type
tissue <- "Stomach"
# Guess tissue type
# tissue_guess = auto_detect_tissue_type(path_to_db_file = database, seuratObject = mouse.dat, scaled = FALSE, assay = "RNA")
# if scaled = TRUE, make sure the data is scaled, as seuratObject[[assay]]@scale.data is used. If you just created a Seurat object, without any scaling and normalization, set scaled = FALSE, seuratObject[[assay]]@counts will be used         
# Prepare gene sets
gs_list <- gene_sets_prepare(database, tissue)

# Assign cell types to each cluster
es.max = sctype_score(scRNAseqData = mouse.dat[["RNA"]]@scale.data, scaled = TRUE, 
                      gs = gs_list$gs_positive, gs2 = gs_list$gs_negative) 

# Merge by cluster
cl_results = do.call("rbind", lapply(unique(mouse.dat@meta.data$seurat_clusters), function(cl){
    es.max.cl = sort(rowSums(es.max[ ,rownames(mouse.dat@meta.data[mouse.dat@meta.data$seurat_clusters==cl, ])]), decreasing = !0)
    head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(mouse.dat@meta.data$seurat_clusters==cl)), 10)
}))
sctype_scores = cl_results %>% group_by(cluster) %>% top_n(n = 1, wt = scores)  

# set low-confident (low ScType score) clusters to "unknown"
sctype_scores$type[as.numeric(as.character(sctype_scores$scores)) < sctype_scores$ncells/4] = "Unknown"
print(sctype_scores[,1:3])
#sctype_score uses positive (gs) and negative (gs2) markers. If you don't want to use negative markers, set gs2 to NULL
```

# Overlay these annotations on the dataset
```{r}
# Score types and plot UMAP
mouse.dat@meta.data$type.sctype = ""
for(j in unique(sctype_scores$cluster)){
  cl_type = sctype_scores[sctype_scores$cluster==j,]; 
  mouse.dat@meta.data$type.sctype[mouse.dat@meta.data$seurat_clusters == j] = as.character(cl_type$type[1])
}
# DimPlot(mouse.dat, reduction = "umap", label = TRUE, repel = TRUE, group.by = 'type.sctype')

# Bubble plot
# load libraries
lapply(c("ggraph","igraph","tidyverse", "data.tree"), library, character.only = T)

# prepare edges
cl_results=cl_results[order(cl_results$cluster),]; edges = cl_results; edges$type = paste0(edges$type,"_",edges$cluster); edges$cluster = paste0("cluster ", edges$cluster); edges = edges[,c("cluster", "type")]; colnames(edges) = c("from", "to"); rownames(edges) <- NULL

# prepare nodes
nodes_lvl1 = sctype_scores[,c("cluster", "ncells")]; nodes_lvl1$cluster = paste0("cluster ", nodes_lvl1$cluster); nodes_lvl1$Colour = "#f1f1ef"; nodes_lvl1$ord = 1; nodes_lvl1$realname = nodes_lvl1$cluster; nodes_lvl1 = as.data.frame(nodes_lvl1);
nodes_lvl2 = c(); 
ccolss= c("#5f75ae","#92bbb8","#64a841","#e5486e","#de8e06","#eccf5a","#b5aa0f","#e4b680","#7ba39d","#b15928","#ffff99", "#6a3d9a","#cab2d6","#ff7f00","#fdbf6f","#e31a1c","#fb9a99","#33a02c","#b2df8a","#1f78b4","#a6cee3", "#03dbfc")
for (i in 1:length(unique(cl_results$cluster))){
  dt_tmp = cl_results[cl_results$cluster == unique(cl_results$cluster)[i], ]; nodes_lvl2 = rbind(nodes_lvl2, data.frame(cluster = paste0(dt_tmp$type,"_",dt_tmp$cluster), ncells = dt_tmp$scores, Colour = ccolss[i], ord = 2, realname = dt_tmp$type))
}

nodes = rbind(nodes_lvl1, nodes_lvl2); nodes$ncells[nodes$ncells<1] = 1;
files_db = openxlsx::read.xlsx(database)[,c("cellName","shortName")]; files_db = unique(files_db); nodes = merge(nodes, files_db, all.x = T, all.y = F, by.x = "realname", by.y = "cellName", sort = F)
nodes$shortName[is.na(nodes$shortName)] = nodes$realname[is.na(nodes$shortName)]; nodes = nodes[,c("cluster", "ncells", "Colour", "ord", "shortName", "realname")]

# Remove inexplicably duplicated rows, where shortname is mesothelial, not mesothelial_cells
nodes <- nodes[nodes$shortName != "Mesothelial", ]

mygraph <- graph_from_data_frame(edges, vertices=nodes)
# Doesn't work due to duplicate vertex names (first column of nodes). This is because for some reason each of the mesothelial cell clusters is duplicated, with one including the short name "mesothelial", and the other "mesothelial_cells"

# Make the graph
gggr<- ggraph(mygraph, layout = 'circlepack', weight=I(ncells)) + 
  geom_node_circle(aes(filter=ord==1,fill=I("#F5F5F5"), colour=I("#D3D3D3")), alpha=0.9) + geom_node_circle(aes(filter=ord==2,fill=I(Colour), colour=I("#D3D3D3")), alpha=0.9) +
  theme_void() + geom_node_text(aes(filter=ord==2, label=realname, colour=I("#ffffff"), fill="white", repel = !1, parse = T, size = I(log(ncells,25)*1.2)))+ geom_node_label(aes(filter=ord==1,  label=realname, colour=I("#000000"), size = I(3), fill="white", parse = T), repel = !0, segment.linetype="dotted")

# Scater is deprecated, use gridExtra::gridarrange instead
# scater::multiplot(DimPlot(mouse.dat, reduction = "umap", label = TRUE, repel = TRUE, cols = ccolss), gggr, cols = 2)

# Use gridExtra to print these graphs next to each other, with the UMAP annotated with original cluster ID's, not annotated cell types
gridExtra::grid.arrange(DimPlot(mouse.dat, reduction = "umap", label = TRUE, repel = TRUE, cols = ccolss), gggr, ncol = 2)
DimPlot(mouse.dat, reduction = "umap", label = TRUE, repel = TRUE, group.by = 'type.sctype')
gggr
DimPlot(mouse.dat, reduction = "umap", label = TRUE, repel = TRUE, group.by = 'type.sctype', split.by = "treat.ident")

# Try and build a version of gggr that maps to annotated cell types.
# This is harder than it looks, you can't just replace "cluster" with "type" in the code for making the first level of nodes, that unfortunately doesn't work
```

# Compare sc-type cell type proportions with metadata values
```{r}
# Cell type vs treatment group (prop)
table(mouse.dat@meta.data[["type.sctype"]], mouse.dat@meta.data[["treat.ident"]]) %>%
prop.table(., 2) %>% round(.,2)

# Cell type vs mouse (prop)
table(mouse.dat@meta.data[["type.sctype"]], mouse.dat@meta.data[["samp.ident.desc"]]) %>%
prop.table(., 2) %>% round(.,2)
```